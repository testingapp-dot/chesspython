<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <!-- mobile-friendly viewport, lock zoom so game remains usable -->
  <!-- Fullscreen and portrait lock -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="full-screen" content="yes">
  <meta name="screen-orientation" content="portrait">

  <title>Hex Game â€” Multiplayer (Mobile) â€” modified</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #f5f5dc;
      font-family: Arial, Helvetica, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100dvh;
      padding: 0;
    }

    #game {
      display: block;
      background: #f5f5dc;
      width: 100%;
      height: 100%;
      touch-action: none;
      border: none;
      margin: 0;
      padding: 0;
    }

    .note {
      position: fixed;
      left: 8px;
      bottom: 8px;
      color: #ccc;
      font-size: 12px;
    }
  </style>
</head>

<body>
  <div class="wrap"><canvas id="game"></canvas></div>
  <div class="note">Mobile-first layout â€” tap dots to play. Run server.js and open this page.</div>

  <script>
    /*
     Changes made:
     - Removed separate "Claim" button. Clicking a free triangle immediately claims it for the player (if it's their turn).
     - End Turn button appears **only** when: (a) it's this player's turn, and (b) there are unclaimed triangles after their move.
     - If after placing a line there are NO new triangles, the client will automatically end the turn (send end_turn) and the next player starts.
     - Player cannot place lines when it's not their turn. Player must place a line first before End Turn can appear.
     - Works both in local fallback mode and with server. Uses optimistic local edges to decide whether to auto-end-turn.
     - **Only addition**: on-screen keyboard in the lobby for editing Name / Room. It does not modify game logic.
    */

    ///// CONFIG
    const LOGICAL_BASE_W = 1000;
    const LOGICAL_BASE_H = 700;
    const BASE_SP = 60;
    const BASE_DR = 10;
    const BASE_FONT_PX = 22;
    const BASE_BIG_FONT_PX = 64;

    const R = 4;
    const STEP_POINTS = 4;
    const DEFAULT_MOVES = 15;

    ///// Networking
    const WS_URL = 'wss://frosty-colden.185-234-114-50.plesk.page';

    ///// DOM + canvas
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    function setupCanvasSize() {
      const DPR = window.devicePixelRatio || 1;
      const cssWidth = window.innerWidth;
      const cssHeight = window.innerHeight;
      canvas.style.width = cssWidth + 'px';
      canvas.style.height = cssHeight + 'px';
      canvas.width = Math.round(cssWidth * DPR);
      canvas.height = Math.round(cssHeight * DPR);
      WIDTH = cssWidth; HEIGHT = cssHeight;
      scale = Math.min(WIDTH / LOGICAL_BASE_W, HEIGHT / LOGICAL_BASE_H);
      DPR_SCALE = DPR;
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
      SP = Math.max(12, Math.round(BASE_SP * scale));
      DR = Math.max(6, Math.round(BASE_DR * scale));
      FONT = `${Math.max(10, Math.round(BASE_FONT_PX * scale))}px Arial`;
      BIG_FONT = `${Math.min(48, Math.max(24, Math.round(BASE_BIG_FONT_PX * Math.max(0.6, scale))))}px Arial`;
      LINE_THICKNESS = Math.max(2, Math.round(4 * scale));
    }
    window.addEventListener('resize', () => { setupCanvasSize(); drawImmediate(); });
    setupCanvasSize();
    window.addEventListener('resize', () => { setupCanvasSize(); drawImmediate(); });

    ///// Colors
    const BG = '#f5f5dc';
    const DOT = '#222629';
    const LINE_COLOR = '#bc1f3d';
    const PLAYERS_COLORS = ['#8e44ad', '#fe8d17', '#2e7d32', '#207ec5'];

    ///// Grid
    const pts = [];
    const idx = {};
    function buildGrid() {
      pts.length = 0;
      for (let q = -R + 1; q < R; q++) {
        const r1 = Math.max(-R + 1, -q - R + 1);
        const r2 = Math.min(R - 1, -q + R - 1);
        for (let rr = r1; rr <= r2; rr++) {
          const pos = toxy(q, rr);
          idx[`${q},${rr}`] = pts.length;
          pts.push({ pos, q, r: rr });
        }
      }
    }
    function toxy(q, r) {
      const x = SP * (1.5 * q);
      const y = SP * (Math.sqrt(3) * (r + q / 2));
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      return [Math.round(x + cssW / 2), Math.round(y + cssH / 2 + Math.max(20 * scale, 10))];
    }
    buildGrid();

    ///// Game state
    let con = [];
    let tris = [];
    let sel = null, turn = 0;
    let moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES];
    let score = [0, 0, 0, 0];
    let game_over = false, winner = null;
    let tri_delay = Math.max(120, Math.round(400 * scale));
    let animating = false, waiting_for_server = false;

    ///// Lobby & UI
    let room_chosen = null, player_index = null, is_host = false, lobby_players = [];
    let input_active = null, input_name = 'Player', input_room = 'room1';
    let selectedPlayerCount = 4;
    let servers = [];
    let serversButtonRects = [];
    let showWinnerOverlay = false, winnerOverlayData = null, winnerOverlayTimeout = null, winnerOverlayCountdown = 0, winnerOverlayInterval = null;
    let playerNames = [];

    ///// Claim state
    let claimMode = false;                // true when player may claim triangles (after placing a line and triangles exist)
    let claimCandidates = [];             // [{points:[a,b,c], center:[x,y], key}]
    let claimRects = [];                  // rects for candidate centers (for hit test)
    let endTurnRect = null;

    ///// Keyboard state (new)
    let keyboardRects = []; // {x,y,w,h,key}
    const MAX_INPUT_LENGTH = 20;

    ///// Helpers
    function sx(x) { return Math.round(x * scale); }
    function sy(y) { return Math.round(y * scale); }
    function sRect(x, y, w, h) { return { x: sx(x), y: sy(y), w: Math.round(w * scale), h: Math.round(h * scale) }; }

    function drawHexagonLocal(ctx, color, center, radius, fill = true, width = 0) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) { const ang = (Math.PI / 180) * (60 * i - 30); const x = center[0] + radius * Math.cos(ang); const y = center[1] + radius * Math.sin(ang); if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); }
      ctx.closePath();
      if (fill) { ctx.fillStyle = color; ctx.fill(); }
      if (width > 0) { ctx.lineWidth = width; ctx.strokeStyle = LINE_COLOR; ctx.stroke(); }
    }
    function drawLineLocal(ctx, a, b, thickness = LINE_THICKNESS) { ctx.beginPath(); ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]); ctx.lineWidth = thickness; ctx.strokeStyle = LINE_COLOR; ctx.stroke(); }
    function roundRectLocal(ctx, x, y, w, h, r, fill = false, fillStyle = '#000') { ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); if (fill) { ctx.fillStyle = fillStyle; ctx.fill(); } else ctx.stroke(); }

    function shadeColor(hex, amt) { const c = hex.replace('#', ''); const num = parseInt(c, 16); let r = (num >> 16) + amt; if (r > 255) r = 255; if (r < 0) r = 0; let g = ((num >> 8) & 0x00FF) + amt; if (g > 255) g = 255; if (g < 0) g = 0; let b = (num & 0x0000FF) + amt; if (b > 255) b = 255; if (b < 0) b = 0; return `rgb(${r},${g},${b})`; }

    ///// UI panels & drawing
    function drawPlayerPanels() {
      const pad = Math.max(6, sx(6));
      const box_w = Math.min(sx(220), Math.round(canvas.clientWidth * 0.45));
      const box_h = Math.min(sy(80), Math.round(canvas.clientHeight * 0.16));
      const positions = [
        [pad, pad],
        [canvas.clientWidth - box_w - pad, pad],
        [pad, canvas.clientHeight - box_h - pad],
        [canvas.clientWidth - box_w - pad, canvas.clientHeight - box_h - pad]
      ];
      ctx.font = FONT; ctx.textBaseline = 'top';
      for (let i = 0; i < 4; i++) {
        const [x, y] = positions[i];
        const color = PLAYERS_COLORS[i];
        const active = (i === turn);
        const disabled = (score[i] >= 15 || moves[i] <= 0);
        const rect_color = disabled ? '#3c3c46' : (active ? shadeColor(color, 40) : '#323238');
        roundRectLocal(ctx, x, y, box_w, box_h, 10, true, rect_color);
        ctx.lineWidth = Math.max(1, Math.round(3 * scale)); ctx.strokeStyle = color; roundRectLocal(ctx, x, y, box_w, box_h, 10, false);
        ctx.fillStyle = '#fff';
        let displayName = null;
        if (Array.isArray(playerNames) && playerNames[i]) displayName = playerNames[i];
        else { const p = lobby_players.find(pp => pp.index === i); if (p && p.name) displayName = p.name; }
        if (!displayName) displayName = `P${i + 1}`;
        const shortName = displayName.length > 14 ? displayName.slice(0, 13) + 'â€¦' : displayName;
        ctx.font = `${Math.max(10, Math.round(16 * scale))}px Arial`; ctx.fillText(shortName, x + sx(10), y + sy(8));
        ctx.font = `${Math.max(10, Math.round(14 * scale))}px Arial`; ctx.fillText(`Score: ${score[i]}`, x + sx(10), y + sy(34));
        ctx.fillText(`Moves: ${moves[i]}`, x + sx(110), y + sy(34));
      }
    }

    function drawKeyboard() {
      keyboardRects = [];
      if (!input_active) return;

      const isMobile = /Mobi|Android/i.test(navigator.userAgent);
      const extraOffset = isMobile ? sy(150) : sy(0);
      const margin = Math.max(8, sx(8));
      const kbHeight = Math.min(Math.round(canvas.clientHeight * 0.32), sy(220));
      const kbTop = canvas.clientHeight - kbHeight - margin - extraOffset;

      // background
      roundRectLocal(ctx, margin, kbTop, canvas.clientWidth - margin * 2, kbHeight, 12, true, '#1b1b1f');

      // rows of keys
      const rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'];
      const rowHeight = Math.round((kbHeight - margin * 3) / 4);
      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        const y = kbTop + margin + r * (rowHeight + margin / 2);
        const keyW = Math.floor((canvas.clientWidth - margin * 4) / row.length) - 6;
        for (let k = 0; k < row.length; k++) {
          const key = row[k];
          const x = margin * 2 + k * (keyW + 6);
          const w = keyW; const h = rowHeight;
          roundRectLocal(ctx, x, y, w, h, 6, true, '#2a2a33');
          ctx.fillStyle = '#fff'; ctx.font = `${Math.max(12, Math.round(16 * scale))}px Arial`;
          const tw = ctx.measureText(key).width;
          ctx.fillText(key, x + (w - tw) / 2, y + Math.round((h - parseInt(ctx.font, 10)) / 2));
          keyboardRects.push({ x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h), key });
        }
      }

      // control row (SPACE, BACK, ENTER)
      const ctrlY = kbTop + margin + rows.length * (rowHeight + margin / 2);
      const spaceW = Math.round((canvas.clientWidth - margin * 6) * 0.55);
      const otherW = Math.round((canvas.clientWidth - margin * 6 - spaceW) / 2);
      const spaceX = margin * 2;
      // SPACE
      roundRectLocal(ctx, spaceX, ctrlY, spaceW, rowHeight, 8, true, '#3c3c46');
      ctx.fillStyle = '#fff'; ctx.font = `${Math.max(12, Math.round(16 * scale))}px Arial`;
      const spaceLabel = 'SPACE';
      ctx.fillText(spaceLabel, spaceX + (spaceW - ctx.measureText(spaceLabel).width) / 2, ctrlY + Math.round((rowHeight - parseInt(ctx.font, 10)) / 2));
      keyboardRects.push({ x: Math.round(spaceX), y: Math.round(ctrlY), w: Math.round(spaceW), h: Math.round(rowHeight), key: ' ' });

      // BACK
      const backX = spaceX + spaceW + 6;
      roundRectLocal(ctx, backX, ctrlY, otherW, rowHeight, 8, true, '#d9534f');
      ctx.fillStyle = '#fff';
      const backLabel = 'BACK';
      ctx.fillText(backLabel, backX + (otherW - ctx.measureText(backLabel).width) / 2, ctrlY + Math.round((rowHeight - parseInt(ctx.font, 10)) / 2));
      keyboardRects.push({ x: Math.round(backX), y: Math.round(ctrlY), w: Math.round(otherW), h: Math.round(rowHeight), key: 'BACK' });

      // ENTER
      const enterX = backX + otherW + 6;
      roundRectLocal(ctx, enterX, ctrlY, otherW, rowHeight, 8, true, '#3cc078');
      ctx.fillStyle = '#000';
      const enterLabel = 'ENTER';
      ctx.fillText(enterLabel, enterX + (otherW - ctx.measureText(enterLabel).width) / 2, ctrlY + Math.round((rowHeight - parseInt(ctx.font, 10)) / 2));
      keyboardRects.push({ x: Math.round(enterX), y: Math.round(ctrlY), w: Math.round(otherW), h: Math.round(rowHeight), key: 'ENTER' });
    }

    function handleVirtualKey(key) {
      if (!input_active) return;
      if (key === 'BACK') {
        if (input_active === 'name') input_name = input_name.slice(0, -1);
        else input_room = input_room.slice(0, -1);
      } else if (key === 'ENTER') {
        input_active = null;
      } else {
        // letter or space
        if (input_active === 'name') {
          if (input_name.length < MAX_INPUT_LENGTH) input_name += key;
        } else {
          if (input_room.length < MAX_INPUT_LENGTH) input_room += key;
        }
      }
      drawImmediate();
    }

    function drawClaimCandidatesAndControls() {
      claimRects = [];
      if (!claimMode) return;

      updateClaimCandidates();

      // draw candidate markers (clickable)
      for (const c of claimCandidates) {
        const center = c.center;
        drawHexagonLocal(ctx, '#2a8bd6', center, Math.max(10, Math.round(12 * scale)), true);
        const r = Math.round(22 * scale);
        claimRects.push({ x: Math.round(center[0] - r), y: Math.round(center[1] - r), w: r * 2, h: r * 2, key: c.key, tri: c.points });
      }

      // draw End Turn only if it's this player's turn (or local mode turn)
      const canShowEnd = claimCandidates.length > 0 && ((ws_client.connected && room_chosen !== null && player_index === turn) || (!ws_client.connected));
      if (!canShowEnd) { endTurnRect = null; return; }

      const w = Math.round(120 * scale), h = Math.round(44 * scale);
      const endX = canvas.clientWidth - w - Math.max(8, sx(8));   // still near right edge
      const endY = (canvas.clientHeight - h) / 2;                 // vertically centered
      roundRectLocal(ctx, endX, endY, w, h, 8, true, '#3cc078');
      ctx.fillStyle = '#000';
      ctx.fillText('End Turn', endX + (w - ctx.measureText('End Turn').width) / 2, endY + Math.round((h - parseInt(ctx.font, 10)) / 2));
      endTurnRect = { x: Math.round(endX), y: Math.round(endY), w: Math.round(w), h: Math.round(h) };
    }

    function drawFrame(sel_local = null, dragPos = null, temp_centers = null) {
      ctx.fillStyle = BG; ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      // edges
      ctx.lineWidth = LINE_THICKNESS; ctx.strokeStyle = LINE_COLOR;
      for (const [a, b] of con) { drawLineLocal(ctx, pts[a].pos, pts[b].pos, LINE_THICKNESS); }

      // triangles -> small dot center
      for (const tri of tris) {
        try {
          const ptsList = tri.points.map(i => pts[i].pos);
          const color = PLAYERS_COLORS[tri.owner] || PLAYERS_COLORS[0];
          const cx = (ptsList[0][0] + ptsList[1][0] + ptsList[2][0]) / 3;
          const cy = (ptsList[0][1] + ptsList[1][1] + ptsList[2][1]) / 3;
          drawHexagonLocal(ctx, color, [cx, cy], Math.max(6, Math.round(8 * scale)), true);
        } catch (e) { }
      }

      // temp centers
      if (temp_centers) for (const [center, color] of temp_centers) drawHexagonLocal(ctx, color, center, Math.max(8, Math.round(10 * scale)), true);

      // points
      for (const p of pts) drawHexagonLocal(ctx, DOT, p.pos, Math.max(4, Math.round(DR)), true);

      // dragging preview
      if (sel_local !== null && dragPos) drawLineLocal(ctx, pts[sel_local].pos, dragPos, LINE_THICKNESS);

      // player panels
      drawPlayerPanels();

      // draw claim candidates & controls (if claim mode)
      drawClaimCandidatesAndControls();

      // winner overlay
      if (showWinnerOverlay && winnerOverlayData) {
        ctx.fillStyle = 'rgba(0,0,0,0.86)'; ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        ctx.font = `bold ${Math.max(18, Math.round(28 * scale))}px Arial`; ctx.fillStyle = '#fff';
        const winnerNameText = winnerOverlayData.winnerName || (typeof winner === 'number' && playerNames[winner] ? playerNames[winner] : ('P' + ((winner || 0) + 1)));
        const text = `${winnerOverlayData.emoji || 'ðŸ†'}  ÐŸÐ¾Ð±ÐµÐ´Ð¸Ñ‚ÐµÐ»ÑŒ: ${winnerNameText}`;
        const w = ctx.measureText(text).width;
        ctx.fillText(text, (canvas.clientWidth - w) / 2, canvas.clientHeight / 2 - 12 * scale);

        // countdown text under the winner message (in Russian as requested)
        if (typeof winnerOverlayCountdown === 'number' && winnerOverlayCountdown > 0) {
          const countdownText = `Ð’ Ð³Ð»Ð°Ð²Ð½Ð¾Ðµ Ð¼ÐµÐ½ÑŽ Ñ‡ÐµÑ€ÐµÐ· ${winnerOverlayCountdown}...`;
          ctx.font = `${Math.max(14, Math.round(20 * scale))}px Arial`;
          const cw = ctx.measureText(countdownText).width;
          ctx.fillText(countdownText, (canvas.clientWidth - cw) / 2, canvas.clientHeight / 2 + 18 * scale);
        }
      }
    }

    function drawImmediate() { drawFrame(sel, drag_pos); }

    function nearScaled(pos) {
      const hitR = Math.max(18, Math.round((DR + 8) * Math.max(1, 1 / scale)));
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i].pos; const dx = p[0] - pos[0], dy = p[1] - pos[1];
        if (dx * dx + dy * dy <= hitR * hitR) return i;
      }
      return null;
    }

    function sortedPair(a, b) { return a < b ? [a, b] : [b, a]; }

    function line_ok_scaled(a, b) {
      const p1 = pts[a], p2 = pts[b];
      const q1 = p1.q, r1 = p1.r, q2 = p2.q, r2 = p2.r;
      const d = Math.max(Math.abs(q1 - q2), Math.abs(r1 - r2), Math.abs((q1 + r1) - (q2 + r2)));
      if (d === 0) return [];
      if (!((q1 - q2 === 0) || (r1 - r2 === 0) || ((q1 + r1) - (q2 + r2) === 0))) return [];
      const dq = (q2 - q1) / d, dr = (r2 - r1) / d;
      const path = [];
      for (let i = 0; i <= d; i++) { const q = Math.round(q1 + dq * i), r = Math.round(r1 + dr * i); const key = `${q},${r}`; if (key in idx) path.push(idx[key]); else return []; }
      return path;
    }

    function find_triangles_local_scaled() {
      const found = [];
      const edgesSet = new Set(con.map(e => `${e[0]}-${e[1]}`));
      const n = pts.length;
      for (let a = 0; a < n; a++) {
        for (let b = a + 1; b < n; b++) {
          if (!edgesSet.has(`${a}-${b}`)) continue;
          for (let c = b + 1; c < n; c++) {
            if (edgesSet.has(`${b}-${c}`) && edgesSet.has(`${a}-${c}`)) found.push([a, b, c]);
          }
        }
      }
      return found;
    }

    function find_triangles_from_edges(edgesList) {
      const found = [];
      const edgesSet = new Set(edgesList.map(e => `${e[0]}-${e[1]}`));
      const n = pts.length;
      for (let a = 0; a < n; a++) {
        for (let b = a + 1; b < n; b++) {
          if (!edgesSet.has(`${a}-${b}`)) continue;
          for (let c = b + 1; c < n; c++) {
            if (edgesSet.has(`${b}-${c}`) && edgesSet.has(`${a}-${c}`)) found.push([a, b, c]);
          }
        }
      }
      return found;
    }

    function tri_center_scaled(tri_pts) {
      const xs = tri_pts.map(p => p[0]); const ys = tri_pts.map(p => p[1]);
      return [Math.floor((xs[0] + xs[1] + xs[2]) / 3), Math.floor((ys[0] + ys[1] + ys[2]) / 3)];
    }

    function end_if_needed_scaled() {
      const active_players = [];
      for (let i = 0; i < 4; i++) if (moves[i] > 0 && score[i] < 15) active_players.push(i);
      if (active_players.length <= 1) { game_over = true; winner = score.indexOf(Math.max(...score)); return true; }
      return false;
    }

    function next_turn_local_scaled() {
      for (let i = 0; i < 4; i++) { turn = (turn + 1) % 4; if (moves[turn] > 0 && score[turn] < 15) break; }
    }

    async function animateTriangleCentersScaled(new_tris_list) {
      animating = true;
      const temp = [];
      for (const item of new_tris_list) {
        temp.push([item.center, item.color]);
        drawFrame(null, null, temp);
        await new Promise(r => setTimeout(r, Math.max(80, tri_delay)));
      }
      animating = false;
    }

    ///// WebSocket client (unchanged)
    class WSClient {
      constructor(url) { this.url = url; this.ws = null; this.queue = []; this.connected = false; }
      connect() {
        return new Promise((res, rej) => {
          try {
            this.ws = new WebSocket(this.url);
            this.ws.addEventListener('open', () => { this.connected = true; console.log('WS open'); res(); });
            this.ws.addEventListener('message', e => { try { const d = JSON.parse(e.data); this.queue.push(d); console.log('SERVER MSG:', d); } catch (err) { } });
            this.ws.addEventListener('close', () => { this.connected = false; this.queue.push({ type: 'closed' }); console.log('WS closed'); });
            this.ws.addEventListener('error', err => { console.error('WS error', err); });
          } catch (e) { rej(e); }
        });
      }
      send(obj) { if (this.ws && this.connected) this.ws.send(JSON.stringify(obj)); }
      recv_nowait() { return this.queue.length ? this.queue.shift() : null; }
    }
    const ws_client = new WSClient(WS_URL);
    function requestRoomsList() { if (ws_client.connected) ws_client.send({ type: 'list_rooms' }); }

    ///// Claim helpers
    function triKeyFromPoints(points) { return points.slice().sort((a, b) => a - b).join(','); }
    function isTriAlreadyClaimed(triPoints) {
      const sortedKey = triKeyFromPoints(triPoints);
      return tris.some(t => triKeyFromPoints(t.points) === sortedKey);
    }
    function updateClaimCandidates() {
      const raw = find_triangles_local_scaled(); // returns sorted triples
      const existingSets = new Set(tris.map(t => triKeyFromPoints(t.points)));
      claimCandidates = [];
      for (const t of raw) {
        const key = triKeyFromPoints(t);
        if (existingSets.has(key)) continue;
        const tri_pts = [pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos];
        const center = tri_center_scaled(tri_pts);
        claimCandidates.push({ points: t.slice(), center, key });
      }
    }

    ///// Server messages handler (extended)
    async function handle_server_messages() {
      const data = ws_client.recv_nowait(); if (!data) return;
      const t = data.type;

      if (t === 'created') {
        room_chosen = data.room; player_index = data.playerIndex;
        if (typeof data.playerName !== 'undefined') { playerNames = playerNames.slice(); playerNames[player_index] = data.playerName; }
        console.log('created', room_chosen, player_index);
      }
      else if (t === 'joined') {
        room_chosen = data.room; player_index = data.playerIndex;
        if (typeof data.playerName !== 'undefined') { playerNames = playerNames.slice(); playerNames[player_index] = data.playerName; }
        console.log('joined', room_chosen, player_index);
      }
      else if (t === 'lobby') {
        lobby_players = data.players || [];
        const maxIdx = Math.max(4, ...(lobby_players.map(p => p.index)));
        playerNames = Array(maxIdx + 1).fill(null);
        for (const p of lobby_players) playerNames[p.index] = p.name;
        const hostIndex = (typeof data.hostIndex !== 'undefined') ? data.hostIndex : 0;
        is_host = (player_index === hostIndex);
      }
      else if (t === 'start') {
        con = []; tris = [];
        score = Array.isArray(data.score) ? data.score : score;
        moves = Array.isArray(data.moves) ? data.moves : moves;
        turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
        game_over = false; winner = null; waiting_for_server = false;
        if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
        else if (Array.isArray(data.players)) {
          playerNames = Array(Math.max(4, data.players.length)).fill(null);
          for (const p of data.players) playerNames[p.index] = p.name;
        }
        claimMode = false; claimCandidates = [];
      }
      else if (t === 'state_update') {
        try { con = (data.con || []).map(pair => [pair[0], pair[1]]); } catch (e) { con = []; }
        if (Array.isArray(data.tris)) {
          tris = data.tris.map(tr => ({ points: tr.points.slice(), owner: tr.owner }));
        } else {
          const new_tris = data.new_tris || [];
          for (const tr of new_tris) {
            const pts_trip = tr.points.slice();
            const owner = tr.owner;
            if (!tris.find(t => arraysEqual(t.points.slice().sort(), pts_trip.slice().sort()))) {
              tris.push({ points: pts_trip, owner });
            }
          }
        }
        score = Array.isArray(data.score) ? data.score : score;
        moves = Array.isArray(data.moves) ? data.moves : moves;
        const prevTurn = turn;
        turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
        game_over = (typeof data.game_over !== 'undefined') ? data.game_over : game_over;
        winner = (typeof data.winner !== 'undefined') ? data.winner : winner;
        waiting_for_server = false;
        if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
        else if (Array.isArray(data.players)) {
          playerNames = Array(Math.max(4, data.players.length)).fill(null);
          for (const p of data.players) playerNames[p.index] = p.name;
        }

        // After authoritative update, recompute candidates
        updateClaimCandidates();

        // If it was our turn and there are no more candidates -> auto end turn (server mode)
        if (claimMode && room_chosen !== null && ws_client.connected && player_index === turn && claimCandidates.length === 0) {
          // send end_turn to server to advance
          waiting_for_server = true;
          ws_client.send({ type: 'end_turn', room: room_chosen });
          // clear local
          claimMode = false;
        }

        // If turn moved to someone else -> disable claimMode
        if (turn !== player_index) {
          claimMode = false;
        }
      }
      else if (t === 'rooms_list') { servers = Array.isArray(data.rooms) ? data.rooms : []; }
      else if (t === 'game_over') {
        // show winner overlay with a 3-second countdown before returning to main menu
        showWinnerOverlay = true;
        winnerOverlayData = { winnerName: data.winnerName || null, emoji: data.emoji || 'ðŸ†' };
        if (!winnerOverlayData.winnerName && typeof data.winner === 'number' && playerNames[data.winner]) winnerOverlayData.winnerName = playerNames[data.winner];

        // clear any previous timers
        if (winnerOverlayTimeout) clearTimeout(winnerOverlayTimeout);
        if (winnerOverlayInterval) clearInterval(winnerOverlayInterval);

        // start a short countdown (3,2,1) visible to the player
        winnerOverlayCountdown = 3;
        winnerOverlayInterval = setInterval(() => {
          winnerOverlayCountdown = Math.max(0, winnerOverlayCountdown - 1);
          if (winnerOverlayCountdown === 0) {
            clearInterval(winnerOverlayInterval); winnerOverlayInterval = null;
          }
        }, 1000);

        // final cleanup after ~3.2s (slightly longer than the visible 3s so the last '1' is readable)
        winnerOverlayTimeout = setTimeout(() => {
          showWinnerOverlay = false; winnerOverlayData = null;
          room_chosen = null; player_index = null; lobby_players = [];
          con = []; tris = []; score = [0, 0, 0, 0]; moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES];
          winnerOverlayCountdown = 0;
          requestRoomsList();
        }, 3200);

        // keep waiting_for_server false so UI remains responsive
        waiting_for_server = false;
      }
      else if (t === 'leave_room') {
        room_chosen = null;
        player_index = null;
        is_host = false;
        lobby_players = [];
        con = []; tris = [];
        score = [0, 0, 0, 0];
        moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES];
        claimMode = false; claimCandidates = [];
        waiting_for_server = false;
        requestRoomsList();
      }
      else if (t === 'closed') { console.log('server closed connection'); }
      else if (t === 'error') { console.warn('server error:', data.message); }
    }

    function arraysEqual(a, b) { if (a.length !== b.length) return false; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false; return true; }

    ///// Pointer handling (includes claim UI hits)
    let drag_pos = null;

    function canvasPosFromEvent(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.round((clientX - rect.left));
      const y = Math.round((clientY - rect.top));
      return { x, y };
    }

    function sendClaimTrianglesToServer(triangles) {
      if (!ws_client.connected || room_chosen === null) { return false; }
      waiting_for_server = true;
      ws_client.send({ type: 'claim_triangles', room: room_chosen, triangles });
      return true;
    }

    function sendEndTurnToServer() {
      if (!ws_client.connected || room_chosen === null) { return false; }
      waiting_for_server = true;
      ws_client.send({ type: 'end_turn', room: room_chosen });
      return true;
    }

    // local fallback: accept triangles (client-side)
    function localAcceptClaims(triangles) {
      const edgesSet = new Set(con.map(e => `${e[0]}-${e[1]}`));
      const existingSets = new Set(tris.map(t => triKeyFromPoints(t.points)));
      const accepted = [];
      for (const tri of triangles) {
        const key = triKeyFromPoints(tri);
        if (existingSets.has(key)) continue;
        const a = tri[0], b = tri[1], c = tri[2];
        const e1 = sortedPair(a, b).join('-'), e2 = sortedPair(b, c).join('-'), e3 = sortedPair(a, c).join('-');
        if (edgesSet.has(e1) && edgesSet.has(e2) && edgesSet.has(e3)) {
          tris.push({ points: tri.slice(), owner: turn });
          accepted.push(tri.slice());
        }
      }
      if (accepted.length) score[turn] += accepted.length;
      updateClaimCandidates();
      const new_tris_for_anim = accepted.map(t => ({ points: t, center: tri_center_scaled([pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos]), color: PLAYERS_COLORS[turn] }));
      if (new_tris_for_anim.length) animateTriangleCentersScaled(new_tris_for_anim);
      // If no more candidates after claiming -> advance turn locally
      if (claimCandidates.length === 0) {
        claimMode = false;
        next_turn_local_scaled();
      }
    }

    async function handlePointerDown(clientX, clientY) {
      const pos = canvasPosFromEvent(clientX, clientY);
      const mx = pos.x, my = pos.y;

      // Lobby input handling...
      if (room_chosen === null && con.length === 0 && tris.length === 0) {
        // first â€” keyboard hit checks (if keyboard visible)
        if (input_active && keyboardRects.length) {
          for (const r of keyboardRects) {
            if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
              // handle virtual key
              handleVirtualKey(r.key);
              return;
            }
          }
        }

        const nameBox = sRect(50, 120, 300, 40);
        if (mx >= nameBox.x && mx <= nameBox.x + nameBox.w && my >= nameBox.y && my <= nameBox.y + nameBox.h) { input_active = 'name'; drawImmediate(); return; }
        const roomBox = sRect(50, 180, 300, 40);
        if (mx >= roomBox.x && mx <= roomBox.x + roomBox.w && my >= roomBox.y && my <= roomBox.y + roomBox.h) { input_active = 'room'; drawImmediate(); return; }

        const pcRegion = sRect(520, 120, 66 * 3 + 6 * 2, 36);
        if (mx >= pcRegion.x && mx <= pcRegion.x + pcRegion.w && my >= pcRegion.y && my <= pcRegion.y + pcRegion.h) {
          const relative = mx - pcRegion.x;
          const idxBtn = Math.floor(relative / Math.round(66 * scale));
          const mapping = [2, 3, 4];
          selectedPlayerCount = mapping[Math.max(0, Math.min(2, idxBtn))];
          drawImmediate(); return;
        }
        const createBtn = sRect(380, 120, 140, 40);
        if (mx >= createBtn.x && mx <= createBtn.x + createBtn.w && my >= createBtn.y && my <= createBtn.y + createBtn.h) {
          if (!ws_client.connected) { try { await ws_client.connect(); } catch (e) { console.error('connect failed', e); return; } }
          ws_client.send({ type: 'create', room: input_room, name: input_name, playerCount: selectedPlayerCount });
          return;
        }
        const joinBtn = sRect(380, 180, 140, 40);
        if (mx >= joinBtn.x && mx <= joinBtn.x + joinBtn.w && my >= joinBtn.y && my <= joinBtn.y + joinBtn.h) {
          if (!ws_client.connected) { try { await ws_client.connect(); } catch (e) { console.error('connect failed', e); return; } }
          ws_client.send({ type: 'join', room: input_room, name: input_name });
          return;
        }
        const startBtn = sRect(800, 120, 140, 40);
        if (is_host && room_chosen && mx >= startBtn.x && mx <= startBtn.x + startBtn.w && my >= startBtn.y && my <= startBtn.y + startBtn.h) {
          ws_client.send({ type: 'start', room: room_chosen });
          return;
        }
        for (let i = 0; i < serversButtonRects.length; i++) {
          const r = serversButtonRects[i];
          if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
            const roomId = servers[i].id;
            if (!ws_client.connected) { try { await ws_client.connect(); } catch (e) { console.error('connect failed', e); return; } }
            ws_client.send({ type: 'join', room: roomId, name: input_name });
            return;
          }
        }
        return;
      }

      // Gameplay: first check claim UI overlaps (if in claimMode)
      if (claimMode) {
        // check candidate hits -> immediate claim when clicked
        for (const r of claimRects) {
          if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
            // immediate claim of this single triangle
            const triangles = [r.tri.slice()];
            if (ws_client.connected && room_chosen !== null) {
              waiting_for_server = true;
              ws_client.send({ type: 'claim_triangles', room: room_chosen, triangles });
            } else {
              localAcceptClaims(triangles);
            }
            drawImmediate();
            return;
          }
        }
        // check end turn button
        if (endTurnRect && mx >= endTurnRect.x && mx <= endTurnRect.x + endTurnRect.w && my >= endTurnRect.y && my <= endTurnRect.y + endTurnRect.h) {
          if (ws_client.connected && room_chosen !== null) {
            waiting_for_server = true;
            ws_client.send({ type: 'end_turn', room: room_chosen });
          } else {
            claimMode = false;
            next_turn_local_scaled();
          }
          drawImmediate();
          return;
        }
        // clicking elsewhere while in claimMode does nothing (player must claim or end turn)
        return;
      }

      // normal gameplay line drawing (when not in claimMode)
      if (animating || waiting_for_server) return;
      if (game_over) return;
      if (score[turn] >= 15 || moves[turn] <= 0) { next_turn_local_scaled(); return; }

      // IMPORTANT: prevent making move when connected and not your player index
      if (ws_client.connected && room_chosen !== null && player_index !== null && player_index !== undefined && player_index !== turn) {
        // not your turn â€” ignore taps for line creation
        return;
      }

      const i = nearScaled([mx, my]);
      if (i !== null) {
        if (sel === null) { sel = i; drag_pos = [mx, my]; drawImmediate(); return; }
        else if (i !== sel) {
          const path = line_ok_scaled(sel, i);
          if (path.length === STEP_POINTS) {
            let made_line = false;
            const newEdges = [];
            for (let k = 0; k < path.length - 1; k++) { const a = path[k], b = path[k + 1]; const edge = sortedPair(a, b); if (!con.find(e => e[0] === edge[0] && e[1] === edge[1])) { made_line = true; newEdges.push(edge); } }
            if (made_line) {
              if (ws_client.connected && room_chosen !== null) {
                waiting_for_server = true;
                // optimistic: add edges locally so UI shows them and compute if triangles appear
                for (const e of newEdges) con.push(e);
                // detect triangles on optimistic con
                const hypotheticalEdges = con.slice();
                const raw = find_triangles_from_edges(hypotheticalEdges);
                const existingSets = new Set(tris.map(t => triKeyFromPoints(t.points)));
                const newCandidates = raw.filter(t => !existingSets.has(triKeyFromPoints(t)));
                // send move
                ws_client.send({ type: 'make_move', room: room_chosen, path: path });

                if (newCandidates.length === 0) {
                  // no triangles -> auto end turn
                  ws_client.send({ type: 'end_turn', room: room_chosen });
                  claimMode = false;
                } else {
                  // triangles exist -> enable claim mode (only this player can claim)
                  claimMode = true;
                  updateClaimCandidates();
                }
              } else {
                // local: add edges, enable claimMode only if triangles appear
                for (let k = 0; k < path.length - 1; k++) { const a = path[k], b = path[k + 1]; const edge = sortedPair(a, b); if (!con.find(e => e[0] === edge[0] && e[1] === edge[1])) con.push(edge); }
                updateClaimCandidates();
                if (claimCandidates.length === 0) {
                  // no triangles locally -> auto advance
                  next_turn_local_scaled();
                } else {
                  claimMode = true;
                }
              }
            }
          }
          sel = null; drag_pos = null; drawImmediate();
        }
      }
    }

    function handlePointerMove(clientX, clientY) {
      const pos = canvasPosFromEvent(clientX, clientY);
      const mx = pos.x, my = pos.y;
      if (sel !== null && !animating && !waiting_for_server) { drag_pos = [mx, my]; drawImmediate(); }
    }

    canvas.addEventListener('mousedown', (ev) => { handlePointerDown(ev.clientX, ev.clientY); });
    canvas.addEventListener('mousemove', (ev) => { handlePointerMove(ev.clientX, ev.clientY); });

    canvas.addEventListener('touchstart', (ev) => {
      ev.preventDefault();
      const t = ev.touches[0];
      if (!t) return;
      handlePointerDown(t.clientX, t.clientY);
    });

    // Dragging preview
    canvas.addEventListener('touchmove', (ev) => {
      ev.preventDefault();
      const t = ev.touches[0];
      if (!t) return;
      handlePointerMove(t.clientX, t.clientY);
    });

    // Finish dragging
    canvas.addEventListener('touchend', (ev) => {
      const t = ev.changedTouches[0];
      if (!t) return;

      // Try to place the line at the touch end point
      handlePointerDown(t.clientX, t.clientY);

      // Clear drag preview and selection
      sel = null;
      drag_pos = null;
      drawImmediate();
    });

    window.addEventListener('keydown', (ev) => {
      if (room_chosen === null && con.length === 0 && tris.length === 0 && input_active) {
        if (ev.key === 'Backspace') {
          if (input_active === 'name') input_name = input_name.slice(0, -1);
          else input_room = input_room.slice(0, -1);
        } else if (ev.key === 'Enter') input_active = null;
        else if (ev.key.length === 1) { if (input_active === 'name') input_name += ev.key; else input_room += ev.key; }
        drawImmediate();
      }
    });

    function drawLobbyUI() {
      ctx.fillStyle = '#1e1e24'; ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      ctx.font = `${Math.max(18, Math.round(36 * scale))}px Arial`; ctx.fillStyle = '#fff';
      const title = 'Lobby'; const titleW = ctx.measureText(title).width; ctx.fillText(title, (canvas.clientWidth - titleW) / 2, sy(20));

      const nameBox = sRect(50, 120, 300, 40);
      roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, true, '#32323c');
      ctx.lineWidth = Math.max(1, Math.round(2 * scale)); ctx.strokeStyle = '#c8c8c8'; roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, false);
      ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Name: ' + input_name, nameBox.x + sx(10), nameBox.y + sy(8));

      const roomBox = sRect(50, 180, 300, 40);
      roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, true, '#32323c'); roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, false);
      ctx.fillStyle = '#fff'; ctx.fillText('Room: ' + input_room, roomBox.x + sx(10), roomBox.y + sy(8));

      const counts = [2, 3, 4];
      for (let i = 0; i < counts.length; i++) {
        const x = sx(520) + i * Math.round((66 + 6) * scale);
        const y = sy(120);
        const wRect = Math.round(66 * scale), hRect = Math.round(36 * scale);
        roundRectLocal(ctx, x, y, wRect, hRect, 6, true, (counts[i] === selectedPlayerCount) ? '#3cc078' : '#444');
        ctx.fillStyle = (counts[i] === selectedPlayerCount) ? '#000' : '#fff';
        ctx.font = FONT;
        ctx.fillText(String(counts[i]), x + wRect / 2 - ctx.measureText(String(counts[i])).width / 2, y + Math.round(6 * scale));
      }

      const createBtn = sRect(380, 120, 140, 40);
      const joinBtn = sRect(380, 180, 140, 40);
      roundRectLocal(ctx, createBtn.x, createBtn.y, createBtn.w, createBtn.h, 6, true, '#4682b4');
      roundRectLocal(ctx, joinBtn.x, joinBtn.y, joinBtn.w, joinBtn.h, 6, true, '#4682b4');
      ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Create', createBtn.x + sx(25), createBtn.y + sy(8));
      ctx.fillText('Join', joinBtn.x + sx(35), joinBtn.y + sy(8));

      ctx.fillStyle = '#fff'; ctx.fillText('Players in room:', sx(50), sy(250));
      let y = sy(290); ctx.font = FONT;
      for (const p of lobby_players) { const flag = p.isHost ? ' (host)' : ''; ctx.fillStyle = '#e6e6e6'; ctx.fillText(`${p.index + 1}. ${p.name}${flag}`, sx(60), y); y += sy(30); }

      if (is_host && room_chosen) { roundRectLocal(ctx, sx(800), sy(120), sx(140), sy(40), 6, true, '#3cc078'); ctx.fillStyle = '#000'; ctx.fillText('Start', sx(830), sy(128)); }

      ctx.fillStyle = '#fff'; ctx.fillText('Servers:', sx(520), sy(220)); serversButtonRects = [];
      let syPos = sy(260); ctx.font = `${Math.max(10, Math.round(14 * scale))}px Arial`;
      for (let i = 0; i < servers.length; i++) {
        const sRow = servers[i];
        const rx = sx(520), rw = Math.round(440 * scale), rh = Math.round(40 * scale);
        roundRectLocal(ctx, rx, syPos, rw, rh, 6, true, '#2a2a33');
        ctx.fillStyle = '#fff';
        const label = `${sRow.id} â€” players: ${sRow.players}/${sRow.maxPlayers} ${sRow.started ? '[started]' : ''}`;
        ctx.fillText(label, rx + sx(10), syPos + Math.round(10 * scale));
        const bx = rx + rw - Math.round(80 * scale), by = syPos + Math.round(6 * scale), bw = Math.round(70 * scale), bh = Math.round(28 * scale);
        roundRectLocal(ctx, bx, by, bw, bh, 6, true, '#4682b4');
        ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Join', bx + Math.round(18 * scale), by + Math.round(4 * scale));
        serversButtonRects.push({ x: bx, y: by, w: bw, h: bh });
        syPos += Math.round(54 * scale);
        if (syPos > canvas.clientHeight - Math.round(80 * scale)) break;
      }

      // draw keyboard UI if editing name/room
      if (input_active) drawKeyboard();

      ctx.font = FONT;
    }

    ///// Main loop
    async function mainLoop() {
      try { await handle_server_messages(); } catch (e) { }
      if (room_chosen === null && con.length === 0 && tris.length === 0) {
        drawLobbyUI();
      } else {
        drawFrame(sel, drag_pos);
      }
      requestAnimationFrame(mainLoop);
    }
    requestAnimationFrame(mainLoop);

    (async () => { try { await ws_client.connect(); requestRoomsList(); } catch (e) { console.warn('initial ws connect failed', e); } })();
    setInterval(() => { if (ws_client.connected && room_chosen === null) requestRoomsList(); }, 5000);

    function logState() { console.log({ con, tris, score, moves, turn, room_chosen, player_index, servers, playerNames, claimMode }); }

  </script>
</body>

</html>
