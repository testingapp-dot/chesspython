<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- mobile-friendly viewport, allow fullscreen on PWA-capable browsers -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <title>Hex Game ‚Äî Mobile</title>

  <style>
    :root{
      /* ensure we can use safe-area values in JS/CSS */
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
      --safe-right: env(safe-area-inset-right);
      --bg: #14151a;
    }

    html,body{
      height:100%;
      width:100%;
      margin:0;
      padding:0;
      background:var(--bg);
      -webkit-user-select:none;
      -webkit-touch-callout:none;
      touch-action:none;             /* disable default gestures for canvas */
      overscroll-behavior: none;     /* prevent rubber-band on iOS/Android */
      -webkit-tap-highlight-color: transparent;
      font-family: Arial, Helvetica, sans-serif;
    }

    /* container sized to the visual viewport / safe area */
    .wrap{
      width:100vw;
      height:calc(100dvh - var(--safe-top) - var(--safe-bottom));
      display:flex;
      align-items:center;
      justify-content:center;
      padding-top:var(--safe-top);
      padding-bottom:var(--safe-bottom);
      box-sizing:border-box;
      background:var(--bg);
    }

    /* canvas covers the container. We'll resize it to device pixel ratio in JS */
    #game{
      display:block;
      width:100%;
      height:100%;
      max-width:100%;
      max-height:100%;
      background:var(--bg);
      border-radius:0;
      margin:0;
      padding:0;
      touch-action:none;
      outline:none;
    }

    /* Small fullscreen hint overlay (appears until user taps once) */
    .hint {
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:18px;
      background:rgba(0,0,0,0.5);
      color:#fff;
      padding:8px 12px;
      border-radius:12px;
      font-size:13px;
      z-index:40;
      backdrop-filter: blur(4px);
      pointer-events:none;
    }

    /* Hide on fullscreen (class toggled by JS) */
    .hint.hidden{ display:none; }

    /* for safety on landscape: limit max width and center */
    @media (orientation: landscape) {
      .wrap { align-items:center; justify-content:center; }
      #game { max-width:900px; max-height:90dvh; }
    }

    /* small accessibility bump for join/create buttons clickable area if drawn on canvas */
    button.offscreen {
      position: absolute; opacity:0; pointer-events:none;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <canvas id="game" role="application" aria-label="Hex game"></canvas>
  </div>

  <div class="hint" id="hint">Tap once to enter fullscreen & enable best experience</div>

<script>
/*
  Mobile-first Hex Game client (improved responsive + safe-area + fullscreen prompt)
  - Replace your previous script with this; logic mostly unchanged, resizing handled better.
  - On first user tap we try requestFullscreen() (must be a user gesture).
*/

///// CONFIG
const LOGICAL_BASE_W = 1000;
const LOGICAL_BASE_H = 700;
const BASE_SP = 60;
const BASE_DR = 10;
const BASE_FONT_PX = 22;
const BASE_BIG_FONT_PX = 64;

const R = 4;
const STEP_POINTS = 4; // required path length
const DEFAULT_MOVES = 15;

const WS_URL = 'wss://frosty-colden.185-234-114-50.plesk.page';

///// DOM
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });
const hint = document.getElementById('hint');

///// viewport-aware sizing
let WIDTH = 0, HEIGHT = 0, scale = 1, DPR = 1;
let SP = BASE_SP, DR = BASE_DR, FONT = '16px Arial', BIG_FONT = '48px Arial', LINE_THICKNESS = 4;

function getViewportSize(){
  // prefer visualViewport (gives correct available area with keyboard)
  if (window.visualViewport){
    return { w: window.visualViewport.width, h: window.visualViewport.height };
  }
  return { w: window.innerWidth, h: window.innerHeight };
}

function setupCanvasSize(){
  const vp = getViewportSize();
  // account for safe area insets using CSS env (JS cannot read env directly cross-browser),
  // but visualViewport generally already excludes browser UI. We'll keep small margins.
  const cssW = Math.max(320, vp.w); // never smaller than small phone width
  const cssH = Math.max(320, vp.h);

  // fill available area but preserve game's logical aspect so UI doesn't squish
  // We'll compute scale as min of width and height factors to keep UI readable
  const availableW = cssW;
  const availableH = cssH;
  const aspect = LOGICAL_BASE_W / LOGICAL_BASE_H;
  // choose layout: prioritize width in portrait, but ensure grid fits vertically
  let targetW = availableW;
  let targetH = Math.round(availableW / aspect);
  if (targetH > availableH) {
    targetH = availableH;
    targetW = Math.round(targetH * aspect);
  }

  DPR = window.devicePixelRatio || 1;
  canvas.style.width = targetW + 'px';
  canvas.style.height = targetH + 'px';
  canvas.width = Math.round(targetW * DPR);
  canvas.height = Math.round(targetH * DPR);

  WIDTH = targetW;
  HEIGHT = targetH;

  // scale for drawing (map logical base to chosen targetW)
  scale = targetW / LOGICAL_BASE_W;

  // scaled constants
  SP = Math.max(12, Math.round(BASE_SP * scale));
  DR = Math.max(6, Math.round(BASE_DR * scale));
  FONT = `${Math.max(10, Math.round(BASE_FONT_PX * scale))}px Arial`;
  BIG_FONT = `${Math.min(48, Math.max(24, Math.round(BASE_BIG_FONT_PX * Math.max(0.6, scale))))}px Arial`;
  LINE_THICKNESS = Math.max(2, Math.round(4 * scale));

  // set transform so 1 unit in canvas CSS = 1 logical CSS pixel; we'll draw using client coords
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

  // rebuild grid positions to new sizes
  buildGrid();
  drawImmediate();
}

// Recalculate when visualViewport changes (especially on mobile when keyboard appears)
if (window.visualViewport){
  window.visualViewport.addEventListener('resize', () => { setupCanvasSize(); });
  window.visualViewport.addEventListener('scroll', () => { setupCanvasSize(); });
}
window.addEventListener('orientationchange', () => { setTimeout(setupCanvasSize, 260); });
window.addEventListener('resize', () => { setTimeout(setupCanvasSize, 80); });

// ---------- Game logic variables (kept like original) ----------
const pts = [];
const idx = {};
function buildGrid(){
  pts.length = 0;
  for (let q = -R+1; q < R; q++){
    const r1 = Math.max(-R+1, -q-R+1);
    const r2 = Math.min(R-1, -q+R-1);
    for (let rr = r1; rr <= r2; rr++){
      const pos = toxy(q, rr);
      idx[`${q},${rr}`] = pts.length;
      pts.push({ pos, q, r: rr });
    }
  }
}
function toxy(q,r){
  // center grid in canvas client area
  const x = SP * (1.5 * q);
  const y = SP * (Math.sqrt(3) * (r + q/2));
  const cssW = canvas.clientWidth;
  const cssH = canvas.clientHeight;
  // vertical offset tuned so UI panels have space
  return [ Math.round(x + cssW/2), Math.round(y + cssH/2 + Math.max(18 * scale, 8)) ];
}

// drawing helpers
const BG = '#14171a';
const DOT = '#222629';
const LINE_COLOR = '#ffffff';
const PLAYERS_COLORS = [ '#ff4500', '#ffd700', '#3cb371', '#1e90ff' ];

function drawHexagonLocal(ctx, color, center, radius, fill=true, width=0){
  ctx.beginPath();
  for (let i=0;i<6;i++){
    const ang = (Math.PI/180) * (60*i - 30);
    const x = center[0] + radius * Math.cos(ang);
    const y = center[1] + radius * Math.sin(ang);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  if (fill) { ctx.fillStyle = color; ctx.fill(); }
  if (width>0) { ctx.lineWidth = width; ctx.strokeStyle = LINE_COLOR; ctx.stroke(); }
}
function drawLineLocal(ctx, a, b, thickness=LINE_THICKNESS){
  ctx.beginPath(); ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]); ctx.lineWidth = thickness; ctx.strokeStyle = LINE_COLOR; ctx.stroke();
}
function roundRectLocal(ctx,x,y,w,h,r, fill=false, fillStyle='#000'){
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  if (fill){ ctx.fillStyle = fillStyle; ctx.fill(); } else ctx.stroke();
}
function shadeColor(hex, amt){
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  let r = (num >> 16) + amt; if (r>255) r=255; if(r<0) r=0;
  let g = ((num >> 8) & 0x00FF) + amt; if (g>255) g=255; if(g<0) g=0;
  let b = (num & 0x0000FF) + amt; if (b>255) b=255; if(b<0) b=0;
  return `rgb(${r},${g},${b})`;
}

// game state
let con = [], tris = [], sel = null, turn = 0;
let moves = [DEFAULT_MOVES,DEFAULT_MOVES,DEFAULT_MOVES,DEFAULT_MOVES];
let score = [0,0,0,0];
let game_over = false, winner = null;
let tri_delay = Math.max(120, Math.round(400 * scale));
let animating = false, waiting_for_server = false;

// lobby/ui
let room_chosen = null, player_index = null, is_host = false, lobby_players = [];
let input_active = null, input_name = 'Player', input_room = 'room1';
let selectedPlayerCount = 4;
let servers = [], serversButtonRects = [];
let showWinnerOverlay = false, winnerOverlayData = null, winnerOverlayTimeout = null;
let playerNames = [];

function sx(x){ return Math.round(x * scale); }
function sy(y){ return Math.round(y * scale); }
function sRect(x,y,w,h){ return { x: sx(x), y: sy(y), w: Math.round(w*scale), h: Math.round(h*scale) }; }

function drawPlayerPanels(){
  const pad = Math.max(6, sx(6));
  const box_w = Math.min(sx(220), Math.round(canvas.clientWidth * 0.45));
  const box_h = Math.min(sy(80), Math.round(canvas.clientHeight * 0.16));
  const positions = [
    [pad,pad],
    [canvas.clientWidth - box_w - pad, pad],
    [pad, canvas.clientHeight - box_h - pad],
    [canvas.clientWidth - box_w - pad, canvas.clientHeight - box_h - pad]
  ];
  ctx.font = FONT; ctx.textBaseline='top';
  for (let i=0;i<4;i++){
    const [x,y] = positions[i];
    const color = PLAYERS_COLORS[i];
    const active = (i === turn);
    const disabled = (score[i] >= 15 || moves[i] <= 0);
    const rect_color = disabled ? '#3c3c46' : (active ? shadeColor(color,40) : '#323238');
    roundRectLocal(ctx,x,y,box_w,box_h,10,true,rect_color);
    ctx.lineWidth = Math.max(1, Math.round(3*scale)); ctx.strokeStyle = color; roundRectLocal(ctx,x,y,box_w,box_h,10,false);
    ctx.fillStyle = '#fff';

    let displayName = null;
    if (Array.isArray(playerNames) && playerNames[i]) displayName = playerNames[i];
    else {
      const p = lobby_players.find(pp => pp.index === i);
      if (p && p.name) displayName = p.name;
    }
    if (!displayName) displayName = `P${i+1}`;
    const shortName = displayName.length > 14 ? displayName.slice(0,13) + '‚Ä¶' : displayName;

    ctx.font = `${Math.max(10, Math.round(16 * scale))}px Arial`;
    ctx.fillText(shortName, x + sx(10), y + sy(8));
    ctx.font = `${Math.max(10, Math.round(14 * scale))}px Arial`;
    ctx.fillText(`Score: ${score[i]}`, x + sx(10), y + sy(34));
    ctx.fillText(`Moves: ${moves[i]}`, x + sx(110), y + sy(34));
  }
}

function drawFrame(sel_local=null, dragPos=null, temp_centers=null){
  ctx.fillStyle = BG; ctx.fillRect(0,0, canvas.clientWidth, canvas.clientHeight);

  // edges
  ctx.lineWidth = LINE_THICKNESS; ctx.strokeStyle = LINE_COLOR;
  for (const [a,b] of con){ drawLineLocal(ctx, pts[a].pos, pts[b].pos, LINE_THICKNESS); }

  // triangles -> small dot center
  for (const tri of tris){
    try{
      const ptsList = tri.points.map(i=>pts[i].pos);
      const color = PLAYERS_COLORS[tri.owner] || PLAYERS_COLORS[0];
      const cx = (ptsList[0][0] + ptsList[1][0] + ptsList[2][0]) / 3;
      const cy = (ptsList[0][1] + ptsList[1][1] + ptsList[2][1]) / 3;
      drawHexagonLocal(ctx, color, [cx,cy], Math.max(6, Math.round(8*scale)), true);
    }catch(e){}
  }

  // temp centers
  if (temp_centers){
    for (const [center, color] of temp_centers){ drawHexagonLocal(ctx, color, center, Math.max(8, Math.round(10*scale)), true); }
  }

  // points
  for (const p of pts){ drawHexagonLocal(ctx, DOT, p.pos, Math.max(4, Math.round(DR)), true); }

  // dragging preview
  if (sel_local !== null && dragPos){ drawLineLocal(ctx, pts[sel_local].pos, dragPos, LINE_THICKNESS); }

  // player panels
  drawPlayerPanels();

  // winner overlay
  if (showWinnerOverlay && winnerOverlayData){
    ctx.fillStyle = 'rgba(0,0,0,0.86)'; ctx.fillRect(0,0, canvas.clientWidth, canvas.clientHeight);
    ctx.font = `bold ${Math.max(18, Math.round(28*scale))}px Arial`; ctx.fillStyle = '#fff';
    const winnerNameText = winnerOverlayData.winnerName || (typeof winner === 'number' && playerNames[winner] ? playerNames[winner] : ('P' + ((winner||0)+1)));
    const text = `${winnerOverlayData.emoji || 'üèÜ'}  –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winnerNameText}`;
    const w = ctx.measureText(text).width;
    ctx.fillText(text, (canvas.clientWidth - w)/2, canvas.clientHeight/2 - 12*scale);
  }
}

function drawImmediate(){ drawFrame(sel, drag_pos); }

function nearScaled(pos){
  // bigger touch area multiplier for usability
  const hitR = Math.max(18, Math.round((DR + 10) * Math.max(1, 1/scale)));
  for (let i=0;i<pts.length;i++){
    const p = pts[i].pos; const dx = p[0]-pos[0], dy = p[1]-pos[1];
    if (dx*dx + dy*dy <= hitR * hitR) return i;
  }
  return null;
}

function sortedPair(a,b){ return a < b ? [a,b] : [b,a]; }

function line_ok_scaled(a,b){
  const p1 = pts[a], p2 = pts[b];
  const q1 = p1.q, r1 = p1.r, q2 = p2.q, r2 = p2.r;
  const d = Math.max(Math.abs(q1-q2), Math.abs(r1-r2), Math.abs((q1+r1)-(q2+r2)));
  if (d===0) return [];
  if (!((q1-q2===0) || (r1-r2===0) || ((q1+r1)-(q2+r2)===0))) return [];
  const dq = (q2-q1)/d, dr = (r2-r1)/d;
  const path = [];
  for (let i=0;i<=d;i++){
    const q = Math.round(q1 + dq*i), r = Math.round(r1 + dr*i);
    const key = `${q},${r}`;
    if (key in idx) path.push(idx[key]); else return [];
  }
  return path;
}

function arraysEqual(a,b){ if (a.length!==b.length) return false; for(let i=0;i<a.length;i++) if (a[i]!==b[i]) return false; return true; }

///// WebSocket client (small wrapper)
class WSClient {
  constructor(url){ this.url = url; this.ws = null; this.queue = []; this.connected = false; }
  connect(){
    return new Promise((res,rej)=>{
      try{
        this.ws = new WebSocket(this.url);
        this.ws.addEventListener('open', ()=>{ this.connected = true; console.log('WS open'); res(); });
        this.ws.addEventListener('message', e=>{ try{ const d=JSON.parse(e.data); this.queue.push(d); }catch(err){} });
        this.ws.addEventListener('close', ()=>{ this.connected = false; this.queue.push({type:'closed'}); console.log('WS closed'); });
        this.ws.addEventListener('error', (err)=>{ console.error('WS error',err); });
      }catch(e){ rej(e); }
    });
  }
  send(obj){ if (this.ws && this.connected) this.ws.send(JSON.stringify(obj)); }
  recv_nowait(){ return this.queue.length ? this.queue.shift() : null; }
}
const ws_client = new WSClient(WS_URL);

function requestRoomsList(){ if (ws_client.connected) ws_client.send({ type: 'list_rooms' }); }

async function handle_server_messages(){
  const data = ws_client.recv_nowait(); if (!data) return;
  const t = data.type;
  if (t === 'created'){
    room_chosen = data.room; player_index = data.playerIndex;
    if (typeof data.playerName !== 'undefined'){
      playerNames = playerNames.slice(); playerNames[player_index] = data.playerName;
    }
  }
  else if (t === 'joined'){
    room_chosen = data.room; player_index = data.playerIndex;
    if (typeof data.playerName !== 'undefined'){
      playerNames = playerNames.slice(); playerNames[player_index] = data.playerName;
    }
  }
  else if (t === 'lobby'){
    lobby_players = data.players || [];
    const maxIdx = Math.max(4, ...(lobby_players.map(p=>p.index)));
    playerNames = Array(maxIdx+1).fill(null);
    for (const p of lobby_players) playerNames[p.index] = p.name;
    const hostIndex = (typeof data.hostIndex !== 'undefined') ? data.hostIndex : 0;
    is_host = (player_index === hostIndex);
  }
  else if (t === 'start'){
    con = []; tris = [];
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = false; winner = null; waiting_for_server = false;
    if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
    else if (Array.isArray(data.players)){
      playerNames = Array(Math.max(4, data.players.length)).fill(null);
      for (const p of data.players) playerNames[p.index] = p.name;
    }
  }
  else if (t === 'state_update'){
    try { con = (data.con || []).map(pair => [pair[0], pair[1]]); } catch(e){ con = []; }
    if (Array.isArray(data.tris)) {
      tris = data.tris.map(tr => ({ points: tr.points.slice(), owner: tr.owner }));
    } else {
      const new_tris = data.new_tris || [];
      for (const tr of new_tris){
        const pts_trip = tr.points.slice();
        const owner = tr.owner;
        if (!tris.find(t=>arraysEqual(t.points.slice().sort(), pts_trip.slice().sort()))){
          tris.push({points:pts_trip, owner});
        }
      }
    }
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = (typeof data.game_over !== 'undefined') ? data.game_over : game_over;
    winner = (typeof data.winner !== 'undefined') ? data.winner : winner;
    waiting_for_server = false;
    if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
    else if (Array.isArray(data.players)){
      playerNames = Array(Math.max(4, data.players.length)).fill(null);
      for (const p of data.players) playerNames[p.index] = p.name;
    }
  }
  else if (t === 'rooms_list'){ servers = Array.isArray(data.rooms) ? data.rooms : []; }
  else if (t === 'game_over'){
    showWinnerOverlay = true;
    winnerOverlayData = { winnerName: data.winnerName || null, emoji: data.emoji || 'üèÜ' };
    if (!winnerOverlayData.winnerName && typeof data.winner === 'number' && playerNames[data.winner]) winnerOverlayData.winnerName = playerNames[data.winner];
    if (winnerOverlayTimeout) clearTimeout(winnerOverlayTimeout);
    winnerOverlayTimeout = setTimeout(()=>{
      showWinnerOverlay = false;
      winnerOverlayData = null;
      room_chosen = null;
      player_index = null;
      lobby_players = [];
      con = [];
      tris = [];
      score = [0,0,0,0];
      moves = [DEFAULT_MOVES,DEFAULT_MOVES,DEFAULT_MOVES,DEFAULT_MOVES];
      requestRoomsList();
    }, 3000);
  }
  else if (t === 'closed'){ console.log('server closed connection'); }
  else if (t === 'error'){ console.warn('server error:', data.message); }
}

///// Pointer handling, but also trigger fullscreen on first user gesture
let firstGestureDone = false;
let drag_pos = null;

function tryEnterFullscreen(){
  if (firstGestureDone) return;
  firstGestureDone = true;
  // hide hint ASAP
  hint.classList.add('hidden');

  // request fullscreen on canvas's parent (wrap)
  const wrap = document.querySelector('.wrap');
  if (wrap && wrap.requestFullscreen){
    try { wrap.requestFullscreen().catch(()=>{}); } catch(e){}
  } else if (canvas.requestFullscreen){
    try { canvas.requestFullscreen().catch(()=>{}); } catch(e){}
  }
  // some browsers (iOS Safari) don't support this; it's optional.
  // Resize after a moment to allow fullscreen to engage
  setTimeout(setupCanvasSize, 350);
}

function canvasPosFromEvent(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const x = Math.round(clientX - rect.left);
  const y = Math.round(clientY - rect.top);
  return { x, y };
}

async function handlePointerDown(clientX, clientY){
  // first user gesture => try fullscreen
  tryEnterFullscreen();

  const pos = canvasPosFromEvent(clientX, clientY);
  const mx = pos.x, my = pos.y;

  // LOBBY area detection left as in original code: if lobby, detect UI regions
  // (we keep coordinates relative to logical scale using sRect)
  if (room_chosen === null && con.length===0 && tris.length===0){
    const nameBox = sRect(50,120,300,40);
    if (mx >= nameBox.x && mx <= nameBox.x + nameBox.w && my >= nameBox.y && my <= nameBox.y + nameBox.h){ input_active = 'name'; drawImmediate(); return; }
    const roomBox = sRect(50,180,300,40);
    if (mx >= roomBox.x && mx <= roomBox.x + roomBox.w && my >= roomBox.y && my <= roomBox.y + roomBox.h){ input_active = 'room'; drawImmediate(); return; }

    const pcRegion = sRect(520,120, 66*3 + 6*2,36);
    if (mx >= pcRegion.x && mx <= pcRegion.x + pcRegion.w && my >= pcRegion.y && my <= pcRegion.y + pcRegion.h){
      const relative = mx - pcRegion.x;
      const idxBtn = Math.floor(relative / Math.round(66 * scale));
      const mapping = [2,3,4];
      selectedPlayerCount = mapping[Math.max(0, Math.min(2, idxBtn))];
      drawImmediate(); return;
    }

    const createBtn = sRect(380,120,140,40);
    if (mx >= createBtn.x && mx <= createBtn.x + createBtn.w && my >= createBtn.y && my <= createBtn.y + createBtn.h){
      if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
      ws_client.send({ type:'create', room: input_room, name: input_name, playerCount: selectedPlayerCount });
      return;
    }

    const joinBtn = sRect(380,180,140,40);
    if (mx >= joinBtn.x && mx <= joinBtn.x + joinBtn.w && my >= joinBtn.y && my <= joinBtn.y + joinBtn.h){
      if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
      ws_client.send({ type:'join', room: input_room, name: input_name });
      return;
    }

    const startBtn = sRect(800,120,140,40);
    if (is_host && room_chosen && mx >= startBtn.x && mx <= startBtn.x + startBtn.w && my >= startBtn.y && my <= startBtn.y + startBtn.h){
      ws_client.send({ type:'start', room: room_chosen });
      return;
    }

    for (let i=0;i<serversButtonRects.length;i++){
      const r = serversButtonRects[i];
      if (mx >= r.x && mx <= r.x+r.w && my >= r.y && my <= r.y+r.h){
        const roomId = servers[i].id;
        if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
        ws_client.send({ type:'join', room: roomId, name: input_name });
        return;
      }
    }
    return;
  }

  // gameplay
  if (animating || waiting_for_server) return;
  if (game_over) return;
  if (score[turn] >= 15 || moves[turn] <= 0){ next_turn_local_scaled(); return; }
  const i = nearScaled([mx,my]);
  if (i !== null){
    if (sel === null){ sel = i; drag_pos = [mx,my]; drawImmediate(); return; }
    else if (i !== sel){
      const path = line_ok_scaled(sel, i);
      if (path.length === STEP_POINTS){
        let made_line = false;
        for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge = sortedPair(a,b); if (!con.find(e=>e[0]===edge[0]&&e[1]===edge[1])) made_line=true; }
        if (made_line){
          if (ws_client.connected && room_chosen !== null){ waiting_for_server = true; try{ ws_client.send({ type:'make_move', room: room_chosen, path: path }); }catch(err){ console.error('send move failed',err); waiting_for_server=false; } }
          else {
            for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge = sortedPair(a,b); if (!con.find(e=>e[0]===edge[0]&&e[1]===edge[1])) con.push(edge); }
            const all_tris = find_triangles_local_scaled();
            const existing_sets = new Set(tris.map(t=>t.points.slice().sort((a,b)=>a-b).join(',')));
            const new_tris_raw = all_tris.filter(t => !existing_sets.has(t.slice().sort((a,b)=>a-b).join(',')));
            const new_tris = [];
            for (const t of new_tris_raw){ const tri_pts = [ pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos ]; const center = tri_center_scaled(tri_pts); new_tris.push({ points: t, center, color: PLAYERS_COLORS[turn] }); }
            if (new_tris.length){ await animateTriangleCentersScaled(new_tris); for (const nt of new_tris){ tris.push({ points: nt.points, owner: turn }); score[turn]++; } }
            moves[turn]--; if (!end_if_needed_scaled()) next_turn_local_scaled();
          }
        }
      }
      sel=null; drag_pos=null; drawImmediate();
    }
  }
}

function handlePointerMove(clientX, clientY){
  const pos = canvasPosFromEvent(clientX, clientY);
  const mx = pos.x, my = pos.y;
  if (sel !== null && !animating && !waiting_for_server){ drag_pos = [mx,my]; drawImmediate(); }
}

canvas.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); const t = ev.touches[0]; if (!t) return; handlePointerDown(t.clientX, t.clientY); });
canvas.addEventListener('touchmove', (ev)=>{ ev.preventDefault(); const t = ev.touches[0]; if (!t) return; handlePointerMove(t.clientX, t.clientY); });
canvas.addEventListener('touchend', (ev)=>{ if (sel !== null){ sel = null; drag_pos = null; drawImmediate(); } });

canvas.addEventListener('mousedown', (ev)=>{ handlePointerDown(ev.clientX, ev.clientY); });
canvas.addEventListener('mousemove', (ev)=>{ handlePointerMove(ev.clientX, ev.clientY); });

// small helpers & local fallback game logic (kept as before)
function find_triangles_local_scaled(){
  const found = [];
  const edgesSet = new Set(con.map(e=>`${e[0]}-${e[1]}`));
  const n = pts.length;
  for (let a=0;a<n;a++){
    for (let b=a+1;b<n;b++){
      if (!edgesSet.has(`${a}-${b}`)) continue;
      for (let c=b+1;c<n;c++){
        if (edgesSet.has(`${b}-${c}`) && edgesSet.has(`${a}-${c}`)) found.push([a,b,c]);
      }
    }
  }
  return found;
}
function tri_center_scaled(tri_pts){
  const xs = tri_pts.map(p=>p[0]); const ys = tri_pts.map(p=>p[1]);
  return [ Math.floor((xs[0]+xs[1]+xs[2])/3), Math.floor((ys[0]+ys[1]+ys[2])/3) ];
}
function end_if_needed_scaled(){
  const active_players = [];
  for (let i=0;i<4;i++) if (moves[i] > 0 && score[i] < 15) active_players.push(i);
  if (active_players.length <= 1){ game_over = true; winner = score.indexOf(Math.max(...score)); return true; }
  return false;
}
function next_turn_local_scaled(){ for (let i=0;i<4;i++){ turn = (turn+1) % 4; if (moves[turn] > 0 && score[turn] < 15) break; } }
async function animateTriangleCentersScaled(new_tris_list){
  animating = true;
  const temp = [];
  for (const item of new_tris_list){
    temp.push([item.center, item.color]);
    drawFrame(null,null,temp);
    await new Promise(r=>setTimeout(r, Math.max(80, tri_delay)));
  }
  animating = false;
}

///// main loop & startup
async function mainLoop(){
  try{ await handle_server_messages(); }catch(e){}
  if (room_chosen === null && con.length===0 && tris.length===0){
    drawLobbyUI();
  } else {
    drawFrame(sel, drag_pos);
  }
  requestAnimationFrame(mainLoop);
}

// simple lobby drawing (like original)
function drawLobbyUI(){
  ctx.fillStyle = '#1e1e24'; ctx.fillRect(0,0, canvas.clientWidth, canvas.clientHeight);
  ctx.font = `${Math.max(18, Math.round(36 * scale))}px Arial`; ctx.fillStyle = '#fff';
  const title = 'Lobby';
  const titleW = ctx.measureText(title).width;
  ctx.fillText(title, (canvas.clientWidth - titleW)/2, sy(20));

  const nameBox = sRect(50,120,300,40);
  roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, true, '#32323c');
  ctx.lineWidth = Math.max(1, Math.round(2*scale)); ctx.strokeStyle = '#c8c8c8'; roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, false);
  ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Name: ' + input_name, nameBox.x + sx(10), nameBox.y + sy(8));

  const roomBox = sRect(50,180,300,40);
  roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, true, '#32323c'); roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, false);
  ctx.fillStyle = '#fff'; ctx.fillText('Room: ' + input_room, roomBox.x + sx(10), roomBox.y + sy(8));

  const counts = [2,3,4];
  for (let i=0;i<counts.length;i++){
    const x = sx(520) + i * Math.round( (66 + 6) * scale );
    const y = sy(120);
    const wRect = Math.round(66 * scale), hRect = Math.round(36 * scale);
    roundRectLocal(ctx, x, y, wRect, hRect, 6, true, (counts[i] === selectedPlayerCount) ? '#3cc078' : '#444');
    ctx.fillStyle = (counts[i] === selectedPlayerCount) ? '#000' : '#fff';
    ctx.font = FONT;
    ctx.fillText(String(counts[i]), x + wRect/2 - ctx.measureText(String(counts[i])).width/2, y + Math.round(6*scale));
  }

  const createBtn = sRect(380,120,140,40);
  const joinBtn = sRect(380,180,140,40);
  roundRectLocal(ctx, createBtn.x, createBtn.y, createBtn.w, createBtn.h, 6, true, '#4682b4');
  roundRectLocal(ctx, joinBtn.x, joinBtn.y, joinBtn.w, joinBtn.h, 6, true, '#4682b4');
  ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Create', createBtn.x + sx(25), createBtn.y + sy(8)); ctx.fillText('Join', joinBtn.x + sx(35), joinBtn.y + sy(8));

  ctx.fillStyle = '#fff'; ctx.fillText('Players in room:', sx(50), sy(250));
  let y = sy(290);
  ctx.font = FONT;
  for (const p of lobby_players){ const flag = p.isHost ? ' (host)' : ''; ctx.fillStyle = '#e6e6e6'; ctx.fillText(`${p.index+1}. ${p.name}${flag}`, sx(60), y); y += sy(30); }

  if (is_host && room_chosen){ roundRectLocal(ctx, sx(800), sy(120), sx(140), sy(40), 6, true, '#3cc078'); ctx.fillStyle = '#000'; ctx.fillText('Start', sx(830), sy(128)); }

  ctx.fillStyle = '#fff'; ctx.fillText('Servers:', sx(520), sy(220));
  serversButtonRects = [];
  let syPos = sy(260);
  ctx.font = `${Math.max(10, Math.round(14 * scale))}px Arial`;
  for (let i=0;i<servers.length;i++){
    const sRow = servers[i];
    const rx = sx(520), rw = Math.round(440 * scale), rh = Math.round(40 * scale);
    roundRectLocal(ctx, rx, syPos, rw, rh, 6, true, '#2a2a33');
    ctx.fillStyle = '#fff';
    const label = `${sRow.id} ‚Äî players: ${sRow.players}/${sRow.maxPlayers} ${sRow.started ? '[started]' : ''}`;
    ctx.fillText(label, rx + sx(10), syPos + Math.round(10 * scale));
    const bx = rx + rw - Math.round(80 * scale), by = syPos + Math.round(6 * scale), bw = Math.round(70 * scale), bh = Math.round(28 * scale);
    roundRectLocal(ctx, bx, by, bw, bh, 6, true, '#4682b4');
    ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Join', bx + Math.round(18 * scale), by + Math.round(4 * scale));
    serversButtonRects.push({ x: bx, y: by, w: bw, h: bh });
    syPos += Math.round(54 * scale);
    if (syPos > canvas.clientHeight - Math.round(80 * scale)) break;
  }
}

// init
setupCanvasSize();
requestAnimationFrame(mainLoop);

// initial ws connect (non-blocking)
(async ()=>{ try{ await ws_client.connect(); requestRoomsList(); }catch(e){ console.warn('initial ws connect failed',e); } })();
setInterval(()=>{ if (ws_client.connected && room_chosen === null) requestRoomsList(); }, 5000);

// hide hint after 6s if user didn't tap
setTimeout(()=>{ if (!firstGestureDone) hint.classList.add('hidden'); }, 6000);

</script>
</body>
</html>
