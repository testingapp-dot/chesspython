<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>Hex Game — Multiplayer (PWA-ready)</title>
<link rel="manifest" href="manifest.json">
<style>
html, body {
  height: 100%;
  margin: 0;
  background: #14151a;
  font-family: Arial, Helvetica, sans-serif;
  overflow: hidden; /* stop scrolling */
}

#game {
  display: block;
  background: #14151a;
  touch-action: none;
  width: 100vw;     /* full viewport width */
  height: 100vh;    /* full viewport height */
  object-fit: contain; /* keep aspect ratio if possible */
}

.note {
  position: fixed;
  left: 8px;
  bottom: 8px;
  color: #ccc;
  font-size: 12px;
}

@media (orientation: landscape) {
  #game {
    width: 100vw;
    height: 100dvh;
  }
}
</style>
</head>
<body>
<canvas id="game" width="1000" height="700"></canvas>
<div class="note">Tip: run the provided server.js and open this page. Works offline as PWA after install.</div>
<script>
/* Hex Game — single-file PWA-ready client
   - Draws nearly-identical UI to original Python/pygame client
   - Connects to WebSocket server at ws://localhost:8080
   - Implements lobby (create/join/start), authoritative state updates, local fallback
   - Self-registers a simple service-worker and manifest via Blob so this single file can behave as a PWA
*/

// --- Constants (keep in sync with server) ---
const R = 4;      // grid radius
const STEP = 4;   // required path length
const SP = 60;    // spacing
const DR = 10;    // dot radius
const STEP_POINTS = 4; // step variable name to match original
const WIDTH = 1000, HEIGHT = 700;

// Colors & fonts
const BG = '#14171b';
const DOT = '#222629';
const LINE_COLOR = '#ffffff';
const PLAYERS_COLORS = [ '#ff0000', '#ffff00', '#00ff00', '#0000ff' ];
const FONT = '22px Arial';
const BIG_FONT = '64px Arial';

// Canvas
const canvas = document.getElementById('game');
canvas.width = WIDTH; canvas.height = HEIGHT;
const ctx = canvas.getContext('2d');
ctx.textBaseline = 'top';

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const width = window.innerWidth;
  const height = window.innerHeight;

  // ВАЖНО: canvas.width = физические пиксели
  canvas.width = width * dpr;
  canvas.height = height * dpr;

  // Визуальный размер (CSS)
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';

  // Масштаб контекста
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Grid construction (q,r) points and index map
const pts = []; // {pos:[x,y], q, r}
const idx = {}; // "q,r"->index
(function buildGrid(){
  for (let q = -R+1; q < R; q++){
    const r1 = Math.max(-R+1, -q-R+1);
    const r2 = Math.min(R-1, -q+R-1);
    for (let rr = r1; rr <= r2; rr++){
      const pos = toxy(q,rr);
      idx[`${q},${rr}`] = pts.length;
      pts.push({ pos, q, r: rr });
    }
  }
})();

function toxy(q,r){
  const x = SP*(1.5*q);
  const y = SP*(Math.sqrt(3)*(r + q/2));
  return [ Math.round(x + WIDTH/2), Math.round(y + HEIGHT/2 + 40) ];
}

// Game state
let con = []; // list of [a,b] with a<b
let tris = []; // list of {points:[a,b,c], owner}
let sel = null; let turn = 0;
let moves = [15,15,15,15]; let score = [0,0,0,0];
let game_over = false; let winner = null;
let tri_delay = 400; // ms
let animating = false; let waiting_for_server = false;

// Lobby state
let room_chosen = null; let player_index = null; let is_host = false; let lobby_players = [];
let input_active = null; let input_name = 'Player'; let input_room = 'room1';

// Mouse interaction
let dragging = false; let drag_pos = null;

// --- Drawing helpers ---
function drawHexagon(ctx, color, center, radius, fill=true, width=0){
  ctx.beginPath();
  for (let i=0;i<6;i++){
    const ang = (Math.PI/180) * (60*i - 30);
    const x = center[0] + radius * Math.cos(ang);
    const y = center[1] + radius * Math.sin(ang);
    if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  if (fill) ctx.fillStyle = color, ctx.fill();
  if (width>0) ctx.lineWidth = width, ctx.strokeStyle = LINE_COLOR, ctx.stroke();
}

function drawLine(ctx, a, b, thickness=4){
  ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineWidth = thickness; ctx.strokeStyle = LINE_COLOR; ctx.stroke();
}

function drawPlayerPanels(){
  const pad = 10; const box_w = 220, box_h = 80;
  const positions = [ [pad,pad], [WIDTH-box_w-pad,pad], [pad,HEIGHT-box_h-pad], [WIDTH-box_w-pad,HEIGHT-box_h-pad] ];
  ctx.font = FONT; ctx.textBaseline='top';
  for (let i=0;i<4;i++){
    const [x,y] = positions[i];
    const color = PLAYERS_COLORS[i];
    const active = (i === turn);
    const disabled = (score[i] >= 15 || moves[i] <= 0);
    const rect_color = disabled ? '#3c3c46' : (active ? shadeColor(color,40) : '#323238');
    // box
    roundRect(ctx,x,y,box_w,box_h,10,true,rect_color);
    ctx.lineWidth = 3; ctx.strokeStyle = color; roundRect(ctx,x,y,box_w,box_h,10,false); // border
    ctx.fillStyle = '#fff';
    ctx.fillText(`P${i+1}`, x+10, y+8);
    ctx.fillText(`Очки: ${score[i]}`, x+10, y+40);
  }
}

function shadeColor(hex, amt){
  // hex like #rrggbb, amt positive to lighten
  const c = hex.replace('#','');
  const num = parseInt(c,16);
  let r = (num >> 16) + amt; if (r>255) r=255; if(r<0) r=0;
  let g = ((num >> 8) & 0x00FF) + amt; if (g>255) g=255; if(g<0) g=0;
  let b = (num & 0x0000FF) + amt; if (b>255) b=255; if(b<0) b=0;
  return `rgb(${r},${g},${b})`;
}

function roundRect(ctx,x,y,w,h,r, fill=false, fillStyle='#000'){
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  if (fill){ ctx.fillStyle = fillStyle; ctx.fill(); }
  else ctx.stroke();
}

function drawFrame(sel_local=null, dragPos=null, temp_centers=null){
  ctx.fillStyle = BG; ctx.fillRect(0,0,WIDTH,HEIGHT);
  // edges
  ctx.lineWidth = 4; ctx.strokeStyle = LINE_COLOR;
  for (const [a,b] of con){ drawLine(ctx, pts[a].pos, pts[b].pos, 4); }
  // triangles
  for (const tri of tris){
    try{
      const ptsList = tri.points.map(i=>pts[i].pos);
      ctx.beginPath(); ctx.moveTo(ptsList[0][0],ptsList[0][1]); ctx.lineTo(ptsList[1][0],ptsList[1][1]); ctx.lineTo(ptsList[2][0],ptsList[2][1]); ctx.closePath();
      ctx.fillStyle = PLAYERS_COLORS[tri.owner] || PLAYERS_COLORS[0]; ctx.fill();
    }catch(e){ }
  }
  // temp centers for animation
  if (temp_centers){
    for (const [center, color] of temp_centers){ drawHexagon(ctx, color, center, 10, true); }
  }
  // points
  for (const p of pts){ drawHexagon(ctx, DOT, p.pos, DR, true); }
  // dragging preview
  if (sel_local !== null && dragPos){ drawLine(ctx, pts[sel_local].pos, dragPos, 4); }
  drawPlayerPanels();
}

// --- Utilities ---
function near(pos){
  for (let i=0;i<pts.length;i++){
    const p = pts[i].pos; const dx = p[0]-pos[0], dy = p[1]-pos[1];
    if (dx*dx + dy*dy <= (DR+8)*(DR+8)) return i;
  }
  return null;
}

function sortedPair(a,b){ return a<b ? [a,b] : [b,a]; }

// Equivalent of line_ok in Python: returns array of indices or []
function line_ok(a,b){
  const p1 = pts[a], p2 = pts[b];
  const q1 = p1.q, r1 = p1.r, q2 = p2.q, r2 = p2.r;
  const d = Math.max(Math.abs(q1-q2), Math.abs(r1-r2), Math.abs((q1+r1)-(q2+r2)));
  if (d===0) return [];
  if (!((q1-q2===0) || (r1-r2===0) || ((q1+r1)-(q2+r2)===0))) return [];
  const dq = (q2-q1)/d, dr = (r2-r1)/d;
  const path = [];
  for (let i=0;i<=d;i++){
    const q = Math.round(q1 + dq*i), r = Math.round(r1 + dr*i);
    const key = `${q},${r}`;
    if (key in idx) path.push(idx[key]); else return [];
  }
  return path;
}

function find_triangles_local(){
  const found = [];
  const edgesSet = new Set(con.map(e=>`${e[0]}-${e[1]}`));
  const n = pts.length;
  for (let a=0;a<n;a++){
    for (let b=a+1;b<n;b++){
      if (!edgesSet.has(`${a}-${b}`)) continue;
      for (let c=b+1;c<n;c++){
        if (edgesSet.has(`${b}-${c}`) && edgesSet.has(`${a}-${c}`)) found.push([a,b,c]);
      }
    }
  }
  return found;
}

function tri_center(tri_pts){
  const xs = tri_pts.map(p=>p[0]); const ys = tri_pts.map(p=>p[1]);
  return [ Math.floor((xs[0]+xs[1]+xs[2])/3), Math.floor((ys[0]+ys[1]+ys[2])/3) ];
}

function end_if_needed(){
  const active_players = [];
  for (let i=0;i<4;i++) if (moves[i] > 0 && score[i] < 15) active_players.push(i);
  if (active_players.length <= 1){ game_over = true; winner = score.indexOf(Math.max(...score)); return true; }
  return false;
}

function next_turn_local(){
  for (let i=0;i<4;i++){ turn = (turn+1)%4; if (moves[turn] > 0 && score[turn] < 15) break; }
}

// animate triangle centers sequentially
async function animateTriangleCenters(new_tris_list){
  animating = true;
  const temp = [];
  for (const item of new_tris_list){
    temp.push([item.center, item.color]);
    drawFrame(null,null,temp);
    await new Promise(resolve => setTimeout(resolve, tri_delay));
  }
  animating = false;
}

// --- WebSocket client ---
const WS_URL = 'wss://frosty-colden.185-234-114-50.plesk.page';
class WSClient {
  constructor(url){ this.url = url; this.ws = null; this.queue = []; this.connected = false; }
  connect(){
    return new Promise((res,rej)=>{
      try{
        this.ws = new WebSocket(this.url);
        this.ws.addEventListener('open', ()=>{ this.connected = true; console.log('WS open'); res(); });
        this.ws.addEventListener('message', e=>{ try{ const d=JSON.parse(e.data); this.queue.push(d); console.log('SERVER MSG:', d);}catch(err){} });
        this.ws.addEventListener('close', ()=>{ this.connected = false; this.queue.push({type:'closed'}); console.log('WS closed'); });
        this.ws.addEventListener('error', (err)=>{ console.error('WS error',err); });
      }catch(e){ rej(e); }
    });
  }
  send(obj){ if (this.ws && this.connected) this.ws.send(JSON.stringify(obj)); }
  recv_nowait(){ return this.queue.length ? this.queue.shift() : null; }
}
const ws_client = new WSClient(WS_URL);

async function handle_server_messages(){
  const data = ws_client.recv_nowait(); if (!data) return;
  const t = data.type;
  if (t === 'created'){
    room_chosen = data.room;
    player_index = data.playerIndex;
    console.log('created', room_chosen, player_index);
  } else if (t === 'joined'){
    room_chosen = data.room;
    player_index = data.playerIndex;
    console.log('joined', room_chosen, player_index);
  } else if (t === 'lobby'){
    lobby_players = data.players || [];
    const hostIndex = (typeof data.hostIndex !== 'undefined') ? data.hostIndex : 0;
    is_host = (player_index === hostIndex);
  } else if (t === 'start'){
    con = [];
    tris = [];
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = (typeof data.game_over !== 'undefined') ? data.game_over : false;
    winner = (typeof data.winner !== 'undefined') ? data.winner : null;
    waiting_for_server = false;
  } else if (t === 'state_update'){
    console.log('Received state_update:', data);
    // authoritative edges
    try { con = (data.con || []).map(pair => [pair[0], pair[1]]); } catch(e){ con = []; }
    // tris
    if (Array.isArray(data.tris)){
      tris = data.tris.map(tr => ({ points: tr.points.slice(), owner: tr.owner }));
    } else {
      const new_tris = data.new_tris || [];
      for (const tr of new_tris){
        const pts_trip = tr.points.slice();
        const owner = tr.owner;
        if (!tris.find(t=>arraysEqual(t.points.slice().sort(), pts_trip.slice().sort()))){
          tris.push({points:pts_trip, owner});
        }
      }
    }
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = (typeof data.game_over !== 'undefined') ? data.game_over : game_over;
    winner = (typeof data.winner !== 'undefined') ? data.winner : winner;
    waiting_for_server = false;
  }
}

function arraysEqual(a,b){ if (a.length!==b.length) return false; for(let i=0;i<a.length;i++) if (a[i]!==b[i]) return false; return true; }

// --- Input handling (canvas) ---
canvas.addEventListener('mousemove', (ev)=>{
  const pos = canvasPos(ev); if (sel !== null && !animating && !waiting_for_server) drag_pos = [pos.x,pos.y];
});
canvas.addEventListener('mousedown', async (ev)=>{
  const pos = canvasPos(ev); const mx = pos.x, my = pos.y;
  // If in lobby (room_chosen===null and empty board)
  if (room_chosen === null && con.length===0 && tris.length===0){
    // simple hitboxes similar to Python positions
    if (50 <= mx && mx <= 350 && 120 <= my && my <= 160) { input_active = 'name'; }
    else if (50 <= mx && mx <= 350 && 180 <= my && my <= 220) { input_active = 'room'; }
    else if (380 <= mx && mx <= 520 && 120 <= my && my <= 160){ // Create
      if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
      ws_client.send({ type:'create', room: input_room, name: input_name });
    } else if (380 <= mx && mx <= 520 && 180 <= my && my <= 220){ // Join
      if (!ws_client.connected){ try{ await ws_client.connect(); }catch(e){ console.error('connect failed',e); return; } }
      ws_client.send({ type:'join', room: input_room, name: input_name });
    } else if (800 <= mx && mx <= 940 && 120 <= my && my <= 160 && is_host && room_chosen){ // Start
      ws_client.send({ type:'start', room: room_chosen });
    }
    return;
  }

  if (animating || waiting_for_server) return;
  if (game_over) return;
  if (score[turn] >= 15 || moves[turn] <= 0){ next_turn_local(); return; }
  const i = near([mx,my]);
  if (i !== null){
    if (sel === null){ sel = i; drag_pos = [mx,my]; }
    else if (i !== sel){
      const path = line_ok(sel, i);
      if (path.length === STEP_POINTS){
        let made_line=false;
        for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge = sortedPair(a,b); if (!con.find(e=>e[0]===edge[0]&&e[1]===edge[1])) made_line=true; }
        if (made_line){
          if (ws_client.connected && room_chosen !== null){ waiting_for_server = true; try{ ws_client.send({ type:'make_move', room: room_chosen, path: path }); }catch(err){ console.error('send move failed',err); waiting_for_server=false; } }
          else { // local-only
            for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge = sortedPair(a,b); if (!con.find(e=>e[0]===edge[0]&&e[1]===edge[1])) con.push(edge); }
            const all_tris = find_triangles_local();
            const existing_sets = new Set(tris.map(t=>t.points.slice().sort((a,b)=>a-b).join(',')));
            const new_tris_raw = all_tris.filter(t => !existing_sets.has(t.slice().sort((a,b)=>a-b).join(',')));
            const new_tris = [];
            for (const t of new_tris_raw){ const tri_pts = [ pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos ]; const center = tri_center(tri_pts); new_tris.push({ points: t, center, color: PLAYERS_COLORS[turn] }); }
            if (new_tris.length){ await animateTriangleCenters(new_tris); for (const nt of new_tris){ tris.push({ points: nt.points, owner: turn }); score[turn]++; } }
            moves[turn]--; if (!end_if_needed()) next_turn_local();
          }
        }
      }
      sel=null; drag_pos=null;
    }
  }
});

// keyboard for lobby input
window.addEventListener('keydown', (ev)=>{
  if (room_chosen === null && con.length===0 && tris.length===0 && input_active){
    if (ev.key === 'Backspace'){
      if (input_active === 'name') input_name = input_name.slice(0,-1);
      else input_room = input_room.slice(0,-1);
    } else if (ev.key === 'Enter') input_active = null;
    else if (ev.key.length === 1){ if (input_active === 'name') input_name += ev.key; else input_room += ev.key; }
  }
});

function canvasPos(ev) {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  // реальные координаты внутри canvas
  const x = (ev.clientX - rect.left) * (canvas.width / rect.width);
  const y = (ev.clientY - rect.top) * (canvas.height / rect.height);

  return { x, y };
}

// --- Main loop ---
let lastTick = performance.now();
async function mainLoop(ts){
  // handle any server messages
  try{ await handle_server_messages(); }catch(e){}
  // draw
  if (room_chosen === null && con.length===0 && tris.length===0){ drawLobbyUI(); }
  else {
    drawFrame(sel, drag_pos);
    if (game_over){
      ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      ctx.font = BIG_FONT; ctx.fillStyle = '#fff';
      const txt = `ПОБЕДИЛ ИГРОК ${winner+1}!`;
      const w = ctx.measureText(txt).width; ctx.fillStyle = '#fff'; ctx.fillText(txt, WIDTH/2 - w/2, HEIGHT/2 - 32);
    }
  }
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

function drawLobbyUI(){
  ctx.fillStyle = '#1e1e24'; ctx.fillRect(0,0,WIDTH,HEIGHT);
  ctx.font = '64px Arial'; ctx.fillStyle = '#fff'; const title = 'Lobby'; ctx.fillText(title, WIDTH/2 - ctx.measureText(title).width/2, 20);
  // name box
  ctx.fillStyle = '#32323c'; roundRect(ctx,50,120,300,40,6,true); ctx.strokeStyle = '#c8c8c8'; ctx.lineWidth=2; roundRect(ctx,50,120,300,40,6,false);
  ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Name: ' + input_name, 60, 128);
  // room box
  ctx.fillStyle = '#32323c'; roundRect(ctx,50,180,300,40,6,true); ctx.strokeStyle = '#c8c8c8'; roundRect(ctx,50,180,300,40,6,false);
  ctx.fillStyle = '#fff'; ctx.fillText('Room: ' + input_room, 60, 188);
  // create/join buttons
  ctx.fillStyle = '#4682b4'; roundRect(ctx,380,120,140,40,6,true); roundRect(ctx,380,180,140,40,6,true);
  ctx.fillStyle = '#fff'; ctx.fillText('Create', 405,128); ctx.fillText('Join', 415,188);
  // player list
  ctx.fillStyle = '#fff'; ctx.fillText('Players in room:', 50,250);
  let y = 290; ctx.font = FONT; for (const p of lobby_players){ const flag = p.isHost ? ' (host)' : ''; ctx.fillStyle = '#e6e6e6'; ctx.fillText(`${p.index+1}. ${p.name}${flag}`, 60, y); y += 30; }
  if (is_host && room_chosen){ ctx.fillStyle = '#3cc078'; roundRect(ctx,800,120,140,40,6,true); ctx.fillStyle = '#000'; ctx.fillText('Start', 830,128); }
}

// --- Start: try connect (non-blocking) ---
(async ()=>{ try{ await ws_client.connect(); }catch(e){ console.warn('initial ws connect failed',e); } })();

// --- Self-contained PWA registration (service worker & manifest created from Blobs) ---
if ('serviceWorker' in navigator){
  const swScript = `self.addEventListener('install',e=>{self.skipWaiting();});self.addEventListener('activate',e=>{clients.claim();});self.addEventListener('fetch',e=>{if (e.request.url.endsWith('/ws')) return; e.respondWith(fetch(e.request));});`;
  const swBlob = new Blob([swScript],{type:'application/javascript'});
  const swUrl = URL.createObjectURL(swBlob);
  navigator.serviceWorker.register(swUrl).then(()=>console.log('sw registered from blob')).catch(e=>console.warn('sw reg failed',e));
  // manifest
  const manifest = {
  name: 'Hex Game',
  short_name: 'HexGame',
  start_url: '.',
  display: 'standalone',
  icons: [
    {
      src: 'https://testingapp-dot.github.io/chesspython/favicon.png',   // здесь путь к файлу PNG
      sizes: '512x512',      // размер иконки
      type: 'image/png'      // MIME тип — обязательно 'image/png'
    }
  ]
};

const manBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
const manUrl = URL.createObjectURL(manBlob);
const link = document.createElement('link');
link.rel = 'manifest';
link.href = manUrl;
document.head.appendChild(link);
}

// --- helpers / debug ---
function logState(){ console.log({con, tris, score, moves, turn, room_chosen, player_index}); }

</script>
</body>
</html>



