<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- mobile-friendly viewport, lock zoom so game remains usable -->
  <!-- Fullscreen and portrait lock -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="full-screen" content="yes">
  <meta name="screen-orientation" content="portrait">

  <title>Hex Game ‚Äî Multiplayer (Mobile)</title>
  <style>
    html, body { margin:0; padding:0; height:100%; width:100%; overflow:hidden; background:#14151a; font-family:Arial, Helvetica, sans-serif; display:flex; justify-content:center; align-items:center; }
    .wrap { display:flex; align-items:center; justify-content:center; width:100vw; height:100dvh; padding:0; }
    #game { display:block; background:#1e1f29; width:100%; height:100%; touch-action:none; border:none; margin:0; padding:0; }
    .note { position:fixed; left:8px; bottom:8px; color:#ccc; font-size:12px; }
  </style>
</head>

<body>
  <div class="wrap"><canvas id="game"></canvas></div>
  <div class="note">Mobile-first layout ‚Äî tap dots to play. Run server.js and open this page.</div>

<script>
/*
 Integrated client: manual triangle claim + End Turn support.
 Works with server endpoints:
  - make_move {type:'make_move', room, path}
  - claim_triangles {type:'claim_triangles', room, triangles: [[a,b,c], ...]}
  - end_turn {type:'end_turn', room}
  - leave_room  <-- server tells client to return to lobby
*/

///// CONFIG
const LOGICAL_BASE_W = 1000;
const LOGICAL_BASE_H = 700;
const BASE_SP = 60;
const BASE_DR = 10;
const BASE_FONT_PX = 22;
const BASE_BIG_FONT_PX = 64;

const R = 4;
const STEP_POINTS = 4;
const DEFAULT_MOVES = 15;

///// Networking
const WS_URL = 'wss://frosty-colden.185-234-114-50.plesk.page';

///// DOM + canvas
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });

function setupCanvasSize() {
  const DPR = window.devicePixelRatio || 1;
  const cssWidth = window.innerWidth;
  const cssHeight = window.innerHeight;
  canvas.style.width = cssWidth + 'px';
  canvas.style.height = cssHeight + 'px';
  canvas.width = Math.round(cssWidth * DPR);
  canvas.height = Math.round(cssHeight * DPR);
  WIDTH = cssWidth; HEIGHT = cssHeight;
  scale = Math.min(WIDTH / LOGICAL_BASE_W, HEIGHT / LOGICAL_BASE_H);
  DPR_SCALE = DPR;
  ctx.setTransform(DPR,0,0,DPR,0,0);
  SP = Math.max(12, Math.round(BASE_SP * scale));
  DR = Math.max(6, Math.round(BASE_DR * scale));
  FONT = `${Math.max(10, Math.round(BASE_FONT_PX * scale))}px Arial`;
  BIG_FONT = `${Math.min(48, Math.max(24, Math.round(BASE_BIG_FONT_PX * Math.max(0.6, scale))))}px Arial`;
  LINE_THICKNESS = Math.max(2, Math.round(4 * scale));
}
window.addEventListener('resize', () => { setupCanvasSize(); drawImmediate(); });
setupCanvasSize();
window.addEventListener('resize', () => { setupCanvasSize(); drawImmediate(); });

///// Colors
const BG = '#14171b';
const DOT = '#222629';
const LINE_COLOR = '#ffffff';
const PLAYERS_COLORS = ['#ff0000', '#ffff00', '#00ff00', '#0000ff'];

///// Grid
const pts = [];
const idx = {};
function buildGrid() {
  pts.length = 0;
  for (let q = -R + 1; q < R; q++) {
    const r1 = Math.max(-R + 1, -q - R + 1);
    const r2 = Math.min(R - 1, -q + R - 1);
    for (let rr = r1; rr <= r2; rr++) {
      const pos = toxy(q, rr);
      idx[`${q},${rr}`] = pts.length;
      pts.push({ pos, q, r: rr });
    }
  }
}
function toxy(q, r) {
  const x = SP * (1.5 * q);
  const y = SP * (Math.sqrt(3) * (r + q / 2));
  const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
  return [Math.round(x + cssW/2), Math.round(y + cssH/2 + Math.max(20 * scale, 10))];
}
buildGrid();

///// Game state
let con = [];
let tris = [];
let sel = null, turn = 0;
let moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES];
let score = [0,0,0,0];
let game_over = false, winner = null;
let tri_delay = Math.max(120, Math.round(400 * scale));
let animating = false, waiting_for_server = false;

///// Lobby & UI
let room_chosen = null, player_index = null, is_host = false, lobby_players = [];
let input_active = null, input_name = 'Player', input_room = 'room1';
let selectedPlayerCount = 4;
let servers = [];
let serversButtonRects = [];
let showWinnerOverlay = false, winnerOverlayData = null, winnerOverlayTimeout = null;
let playerNames = [];

///// New: manual-claim state
let claimMode = false;                // true when player may claim triangles (after placing a line)
let claimCandidates = [];             // [{points:[a,b,c], center:[x,y], key}]
let claimRects = [];                  // rects for candidate centers (for hit test)
let selectedClaimKeys = new Set();    // keys of selected triangles (sorted 'a,b,c')
let claimButtonRect = null, endTurnRect = null;
const MAX_INPUT_LENGTH = 20;

///// Helpers
function sx(x) { return Math.round(x * scale); }
function sy(y) { return Math.round(y * scale); }
function sRect(x,y,w,h) { return { x: sx(x), y: sy(y), w: Math.round(w * scale), h: Math.round(h * scale) }; }

function drawHexagonLocal(ctx, color, center, radius, fill=true, width=0) {
  ctx.beginPath();
  for (let i=0;i<6;i++){ const ang=(Math.PI/180)*(60*i-30); const x=center[0]+radius*Math.cos(ang); const y=center[1]+radius*Math.sin(ang); if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y); }
  ctx.closePath();
  if(fill){ ctx.fillStyle=color; ctx.fill(); }
  if(width>0){ ctx.lineWidth=width; ctx.strokeStyle=LINE_COLOR; ctx.stroke(); }
}
function drawLineLocal(ctx,a,b,thickness=LINE_THICKNESS){ ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineWidth=thickness; ctx.strokeStyle=LINE_COLOR; ctx.stroke(); }
function roundRectLocal(ctx,x,y,w,h,r,fill=false,fillStyle='#000'){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill){ ctx.fillStyle=fillStyle; ctx.fill(); } else ctx.stroke(); }

function shadeColor(hex, amt) { const c = hex.replace('#',''); const num = parseInt(c,16); let r=(num>>16)+amt; if(r>255)r=255; if(r<0)r=0; let g=((num>>8)&0x00FF)+amt; if(g>255)g=255; if(g<0)g=0; let b=(num&0x0000FF)+amt; if(b>255)b=255; if(b<0)b=0; return `rgb(${r},${g},${b})`; }

///// UI panels & drawing
function drawPlayerPanels() {
  const pad = Math.max(6, sx(6));
  const box_w = Math.min(sx(220), Math.round(canvas.clientWidth * 0.45));
  const box_h = Math.min(sy(80), Math.round(canvas.clientHeight * 0.16));
  const positions = [
    [pad,pad],
    [canvas.clientWidth - box_w - pad, pad],
    [pad, canvas.clientHeight - box_h - pad],
    [canvas.clientWidth - box_w - pad, canvas.clientHeight - box_h - pad]
  ];
  ctx.font = FONT; ctx.textBaseline='top';
  for (let i=0;i<4;i++){
    const [x,y]=positions[i];
    const color=PLAYERS_COLORS[i];
    const active=(i===turn);
    const disabled=(score[i]>=15 || moves[i]<=0);
    const rect_color = disabled ? '#3c3c46' : (active ? shadeColor(color,40) : '#323238');
    roundRectLocal(ctx,x,y,box_w,box_h,10,true,rect_color);
    ctx.lineWidth = Math.max(1, Math.round(3*scale)); ctx.strokeStyle=color; roundRectLocal(ctx,x,y,box_w,box_h,10,false);
    ctx.fillStyle='#fff';
    let displayName = null;
    if(Array.isArray(playerNames) && playerNames[i]) displayName = playerNames[i];
    else { const p = lobby_players.find(pp=>pp.index===i); if(p && p.name) displayName=p.name; }
    if(!displayName) displayName = `P${i+1}`;
    const shortName = displayName.length>14 ? displayName.slice(0,13)+'‚Ä¶' : displayName;
    ctx.font = `${Math.max(10, Math.round(16*scale))}px Arial`; ctx.fillText(shortName, x + sx(10), y + sy(8));
    ctx.font = `${Math.max(10, Math.round(14*scale))}px Arial`; ctx.fillText(`Score: ${score[i]}`, x + sx(10), y + sy(34));
    ctx.fillText(`Moves: ${moves[i]}`, x + sx(110), y + sy(34));
  }
}

function drawClaimCandidatesAndControls() {
  claimRects = [];
  if (!claimMode) return;

  // Ensure candidates up to date
  updateClaimCandidates();

  // draw candidate markers
  for (const c of claimCandidates) {
    const center = c.center;
    const key = c.key;
    const selected = selectedClaimKeys.has(key);
    // bigger colored hex if selected
    drawHexagonLocal(ctx, selected ? '#3cc078' : '#2a8bd6', center, Math.max(10, Math.round(12 * scale)), true);
    // small stroke
    ctx.lineWidth = Math.max(1, Math.round(2*scale)); ctx.strokeStyle = '#000'; roundRectLocal(ctx, center[0]-1, center[1]-1, 2, 2, 1, false);
    // store hit rect centered around the center
    const r = Math.round(22 * scale);
    claimRects.push({ x: Math.round(center[0]-r), y: Math.round(center[1]-r), w: r*2, h: r*2, key, tri: c.points });
  }

  // draw bottom controls: Claim and End Turn
  const margin = Math.max(8, sx(8));
  const w = Math.round(120 * scale), h = Math.round(44 * scale);
  const spacing = Math.round(12 * scale);
  const right = canvas.clientWidth - margin;
  const bottom = canvas.clientHeight - margin;

  // End Turn (right)
  const endX = right - w;
  const endY = bottom - h;
  roundRectLocal(ctx, endX, endY, w, h, 8, true, '#3cc078');
  ctx.fillStyle = '#000'; ctx.font = `${Math.max(12, Math.round(16*scale))}px Arial`;
  ctx.fillText('End Turn', endX + (w - ctx.measureText('End Turn').width)/2, endY + Math.round((h - parseInt(ctx.font,10))/2));
  endTurnRect = { x: Math.round(endX), y: Math.round(endY), w: Math.round(w), h: Math.round(h) };

  // Claim (left of End Turn)
  const claimX = endX - spacing - w;
  const claimY = endY;
  roundRectLocal(ctx, claimX, claimY, w, h, 8, true, selectedClaimKeys.size>0 ? '#4682b4' : '#666');
  ctx.fillStyle = '#fff';
  ctx.fillText('Claim', claimX + (w - ctx.measureText('Claim').width)/2, claimY + Math.round((h - parseInt(ctx.font,10))/2));
  claimButtonRect = { x: Math.round(claimX), y: Math.round(claimY), w: Math.round(w), h: Math.round(h) };

  // small label showing how many selected
  ctx.fillStyle = '#fff'; ctx.font = `${Math.max(10, Math.round(12*scale))}px Arial`;
  const selLabel = `Selected: ${selectedClaimKeys.size}`;
  ctx.fillText(selLabel, claimX - Math.round(12 * scale) - ctx.measureText(selLabel).width, claimY + Math.round((h - parseInt(ctx.font,10))/2));
}

function drawFrame(sel_local=null, dragPos=null, temp_centers=null) {
  ctx.fillStyle = BG; ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

  // edges
  ctx.lineWidth = LINE_THICKNESS; ctx.strokeStyle = LINE_COLOR;
  for (const [a,b] of con) { drawLineLocal(ctx, pts[a].pos, pts[b].pos, LINE_THICKNESS); }

  // triangles -> small dot center
  for (const tri of tris) {
    try {
      const ptsList = tri.points.map(i => pts[i].pos);
      const color = PLAYERS_COLORS[tri.owner] || PLAYERS_COLORS[0];
      const cx = (ptsList[0][0] + ptsList[1][0] + ptsList[2][0]) / 3;
      const cy = (ptsList[0][1] + ptsList[1][1] + ptsList[2][1]) / 3;
      drawHexagonLocal(ctx, color, [cx, cy], Math.max(6, Math.round(8 * scale)), true);
    } catch (e) {}
  }

  // temp centers
  if (temp_centers) for (const [center,color] of temp_centers) drawHexagonLocal(ctx, color, center, Math.max(8, Math.round(10 * scale)), true);

  // points
  for (const p of pts) drawHexagonLocal(ctx, DOT, p.pos, Math.max(4, Math.round(DR)), true);

  // dragging preview
  if (sel_local !== null && dragPos) drawLineLocal(ctx, pts[sel_local].pos, dragPos, LINE_THICKNESS);

  // player panels
  drawPlayerPanels();

  // draw claim candidates & controls (if claim mode)
  drawClaimCandidatesAndControls();

  // winner overlay
  if (showWinnerOverlay && winnerOverlayData) {
    ctx.fillStyle = 'rgba(0,0,0,0.86)'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    ctx.font = `bold ${Math.max(18, Math.round(28*scale))}px Arial`; ctx.fillStyle='#fff';
    const winnerNameText = winnerOverlayData.winnerName || (typeof winner === 'number' && playerNames[winner] ? playerNames[winner] : ('P' + ((winner||0)+1)));
    const text = `${winnerOverlayData.emoji || 'üèÜ'}  –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winnerNameText}`;
    const w = ctx.measureText(text).width;
    ctx.fillText(text, (canvas.clientWidth - w)/2, canvas.clientHeight/2 - 12*scale);
  }
}

function drawImmediate() { drawFrame(sel, drag_pos); }

function nearScaled(pos) {
  const hitR = Math.max(18, Math.round((DR + 8) * Math.max(1, 1/scale)));
  for (let i=0;i<pts.length;i++){
    const p = pts[i].pos; const dx = p[0]-pos[0], dy = p[1]-pos[1];
    if (dx*dx + dy*dy <= hitR*hitR) return i;
  }
  return null;
}

function sortedPair(a,b){ return a<b ? [a,b] : [b,a]; }

function line_ok_scaled(a,b){
  const p1 = pts[a], p2 = pts[b];
  const q1=p1.q, r1=p1.r, q2=p2.q, r2=p2.r;
  const d = Math.max(Math.abs(q1-q2), Math.abs(r1-r2), Math.abs((q1+r1)-(q2+r2)));
  if (d===0) return [];
  if (!((q1-q2===0) || (r1-r2===0) || ((q1+r1)-(q2+r2)===0))) return [];
  const dq=(q2-q1)/d, dr=(r2-r1)/d;
  const path=[];
  for (let i=0;i<=d;i++){ const q=Math.round(q1 + dq*i), r=Math.round(r1 + dr*i); const key = `${q},${r}`; if (key in idx) path.push(idx[key]); else return []; }
  return path;
}

function find_triangles_local_scaled() {
  const found = [];
  const edgesSet = new Set(con.map(e => `${e[0]}-${e[1]}`));
  const n = pts.length;
  for (let a=0;a<n;a++){
    for (let b=a+1;b<n;b++){
      if (!edgesSet.has(`${a}-${b}`)) continue;
      for (let c=b+1;c<n;c++){
        if (edgesSet.has(`${b}-${c}`) && edgesSet.has(`${a}-${c}`)) found.push([a,b,c]);
      }
    }
  }
  return found;
}

function tri_center_scaled(tri_pts) {
  const xs = tri_pts.map(p=>p[0]); const ys = tri_pts.map(p=>p[1]);
  return [Math.floor((xs[0]+xs[1]+xs[2])/3), Math.floor((ys[0]+ys[1]+ys[2])/3)];
}

function end_if_needed_scaled(){
  const active_players = [];
  for (let i=0;i<4;i++) if (moves[i]>0 && score[i]<15) active_players.push(i);
  if (active_players.length <= 1) { game_over = true; winner = score.indexOf(Math.max(...score)); return true; }
  return false;
}

function next_turn_local_scaled(){
  for (let i=0;i<4;i++){ turn=(turn+1)%4; if (moves[turn]>0 && score[turn]<15) break; }
}

async function animateTriangleCentersScaled(new_tris_list) {
  animating = true;
  const temp = [];
  for (const item of new_tris_list) {
    temp.push([item.center, item.color]);
    drawFrame(null, null, temp);
    await new Promise(r => setTimeout(r, Math.max(80, tri_delay)));
  }
  animating = false;
}

///// WebSocket client (unchanged)
class WSClient {
  constructor(url) { this.url=url; this.ws=null; this.queue=[]; this.connected=false; }
  connect() {
    return new Promise((res, rej) => {
      try {
        this.ws = new WebSocket(this.url);
        this.ws.addEventListener('open', ()=>{ this.connected=true; console.log('WS open'); res(); });
        this.ws.addEventListener('message', e=>{ try { const d = JSON.parse(e.data); this.queue.push(d); console.log('SERVER MSG:', d); } catch(err){} });
        this.ws.addEventListener('close', ()=>{ this.connected=false; this.queue.push({ type:'closed' }); console.log('WS closed'); });
        this.ws.addEventListener('error', err=>{ console.error('WS error', err); });
      } catch(e){ rej(e); }
    });
  }
  send(obj) { if (this.ws && this.connected) this.ws.send(JSON.stringify(obj)); }
  recv_nowait() { return this.queue.length ? this.queue.shift() : null; }
}
const ws_client = new WSClient(WS_URL);
function requestRoomsList(){ if (ws_client.connected) ws_client.send({ type: 'list_rooms' }); }

///// New helper: update claim candidates from current edges (client-side)
function triKeyFromPoints(points) { return points.slice().sort((a,b)=>a-b).join(','); }
function isTriAlreadyClaimed(triPoints) {
  const sortedKey = triKeyFromPoints(triPoints);
  return tris.some(t => triKeyFromPoints(t.points) === sortedKey);
}
function updateClaimCandidates() {
  // recompute candidates from con (only triangles whose edges exist and are not already in tris)
  const raw = find_triangles_local_scaled(); // returns sorted triples
  const existingSets = new Set(tris.map(t => triKeyFromPoints(t.points)));
  claimCandidates = [];
  for (const t of raw) {
    const key = triKeyFromPoints(t);
    if (existingSets.has(key)) continue;
    // compute center
    const tri_pts = [pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos];
    const center = tri_center_scaled(tri_pts);
    claimCandidates.push({ points: t.slice(), center, key });
  }
}

///// Server messages handler (extended)
async function handle_server_messages() {
  const data = ws_client.recv_nowait(); if (!data) return;
  const t = data.type;

  if (t === 'created') {
    room_chosen = data.room; player_index = data.playerIndex;
    if (typeof data.playerName !== 'undefined') { playerNames = playerNames.slice(); playerNames[player_index] = data.playerName; }
    console.log('created', room_chosen, player_index);
  }
  else if (t === 'joined') {
    room_chosen = data.room; player_index = data.playerIndex;
    if (typeof data.playerName !== 'undefined') { playerNames = playerNames.slice(); playerNames[player_index] = data.playerName; }
    console.log('joined', room_chosen, player_index);
  }
  else if (t === 'lobby') {
    lobby_players = data.players || [];
    const maxIdx = Math.max(4, ...(lobby_players.map(p => p.index)));
    playerNames = Array(maxIdx + 1).fill(null);
    for (const p of lobby_players) playerNames[p.index] = p.name;
    const hostIndex = (typeof data.hostIndex !== 'undefined') ? data.hostIndex : 0;
    is_host = (player_index === hostIndex);
  }
  else if (t === 'start') {
    con = []; tris = [];
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = false; winner = null; waiting_for_server = false;
    if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
    else if (Array.isArray(data.players)) {
      playerNames = Array(Math.max(4, data.players.length)).fill(null);
      for (const p of data.players) playerNames[p.index] = p.name;
    }
    // clean claim state at start
    claimMode = false; claimCandidates=[]; selectedClaimKeys.clear();
  }
  else if (t === 'state_update') {
    try { con = (data.con || []).map(pair=>[pair[0],pair[1]]); } catch(e){ con = []; }
    if (Array.isArray(data.tris)) {
      tris = data.tris.map(tr => ({ points: tr.points.slice(), owner: tr.owner }));
    } else {
      // server may send new_tris only
      const new_tris = data.new_tris || [];
      for (const tr of new_tris) {
        const pts_trip = tr.points.slice();
        const owner = tr.owner;
        if (!tris.find(t => arraysEqual(t.points.slice().sort(), pts_trip.slice().sort()))) {
          tris.push({ points: pts_trip, owner });
        }
      }
    }
    score = Array.isArray(data.score) ? data.score : score;
    moves = Array.isArray(data.moves) ? data.moves : moves;
    const prevTurn = turn;
    turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
    game_over = (typeof data.game_over !== 'undefined') ? data.game_over : game_over;
    winner = (typeof data.winner !== 'undefined') ? data.winner : winner;
    waiting_for_server = false;
    if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
    else if (Array.isArray(data.players)) {
      playerNames = Array(Math.max(4, data.players.length)).fill(null);
      for (const p of data.players) playerNames[p.index] = p.name;
    }

    // If turn moved to someone else -> disable claimMode
    if (turn !== player_index) {
      claimMode = false;
      selectedClaimKeys.clear();
    }
    // update claim candidates after state change
    updateClaimCandidates();
  }
  else if (t === 'rooms_list') { servers = Array.isArray(data.rooms) ? data.rooms : []; }
  else if (t === 'game_over') {
    showWinnerOverlay = true;
    winnerOverlayData = { winnerName: data.winnerName || null, emoji: data.emoji || 'üèÜ' };
    if (!winnerOverlayData.winnerName && typeof data.winner === 'number' && playerNames[data.winner]) winnerOverlayData.winnerName = playerNames[data.winner];
    if (winnerOverlayTimeout) clearTimeout(winnerOverlayTimeout);
    winnerOverlayTimeout = setTimeout(()=>{ showWinnerOverlay=false; winnerOverlayData=null; room_chosen=null; player_index=null; lobby_players=[]; con=[]; tris=[]; score=[0,0,0,0]; moves=[DEFAULT_MOVES,DEFAULT_MOVES,DEFAULT_MOVES,DEFAULT_MOVES]; requestRoomsList(); }, 3000);
  }
  else if (t === 'leave_room') {
    // server asks client to return to lobby (game ended or player kicked)
    room_chosen = null;
    player_index = null;
    is_host = false;
    lobby_players = [];
    con = []; tris = [];
    score = [0,0,0,0];
    moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES];
    claimMode = false; claimCandidates=[]; selectedClaimKeys.clear();
    waiting_for_server = false;
    requestRoomsList();
  }
  else if (t === 'closed') { console.log('server closed connection'); }
  else if (t === 'error') { console.warn('server error:', data.message); }
}

function arraysEqual(a,b){ if(a.length!==b.length) return false; for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false; return true; }

///// Pointer handling (includes claim UI hits)
let drag_pos = null;

function canvasPosFromEvent(clientX, clientY) {
  const rect = canvas.getBoundingClientRect();
  const x = Math.round((clientX - rect.left));
  const y = Math.round((clientY - rect.top));
  return { x, y };
}

function sendClaimTrianglesToServer(triangles) {
  if (!ws_client.connected || room_chosen === null) { return false; }
  waiting_for_server = true;
  ws_client.send({ type: 'claim_triangles', room: room_chosen, triangles });
  return true;
}

function sendEndTurnToServer() {
  if (!ws_client.connected || room_chosen === null) { return false; }
  waiting_for_server = true;
  ws_client.send({ type: 'end_turn', room: room_chosen });
  return true;
}

// local fallback: accept triangles (client-side) ‚Äî used when not connected to WS
function localAcceptClaims(triangles) {
  const edgesSet = new Set(con.map(e=>`${e[0]}-${e[1]}`));
  const existingSets = new Set(tris.map(t => triKeyFromPoints(t.points)));
  const accepted = [];
  for (const tri of triangles) {
    const key = triKeyFromPoints(tri);
    if (existingSets.has(key)) continue;
    // validate edges present
    const a=tri[0], b=tri[1], c=tri[2];
    const e1 = sortedPair(a,b).join('-'), e2 = sortedPair(b,c).join('-'), e3 = sortedPair(a,c).join('-');
    if (edgesSet.has(e1) && edgesSet.has(e2) && edgesSet.has(e3)) {
      tris.push({ points: tri.slice(), owner: turn });
      accepted.push(tri.slice());
    }
  }
  // update score
  if (accepted.length) score[turn] += accepted.length;
  // clear selected claims
  selectedClaimKeys.clear();
  updateClaimCandidates();
  // animate accepted triangles
  const new_tris_for_anim = accepted.map(t => ({ points: t, center: tri_center_scaled([pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos]), color: PLAYERS_COLORS[turn] }));
  if (new_tris_for_anim.length) animateTriangleCentersScaled(new_tris_for_anim);
}

async function handlePointerDown(clientX, clientY) {
  const pos = canvasPosFromEvent(clientX, clientY);
  const mx = pos.x, my = pos.y;

  // Lobby input handling...
  if (room_chosen === null && con.length === 0 && tris.length === 0) {
    // keyboard hit checks remain unchanged (if keyboard shown)
    // name/room box taps
    const nameBox = sRect(50,120,300,40);
    if (mx >= nameBox.x && mx <= nameBox.x + nameBox.w && my >= nameBox.y && my <= nameBox.y + nameBox.h) { input_active = 'name'; drawImmediate(); return; }
    const roomBox = sRect(50,180,300,40);
    if (mx >= roomBox.x && mx <= roomBox.x + roomBox.w && my >= roomBox.y && my <= roomBox.y + roomBox.h) { input_active = 'room'; drawImmediate(); return; }

    // rest of lobby buttons as before...
    // (counts, create, join, start, server list)
    // reuse existing code for those regions:
    const pcRegion = sRect(520,120,66*3+6*2,36);
    if (mx >= pcRegion.x && mx <= pcRegion.x + pcRegion.w && my >= pcRegion.y && my <= pcRegion.y + pcRegion.h) {
      const relative = mx - pcRegion.x;
      const idxBtn = Math.floor(relative / Math.round(66 * scale));
      const mapping = [2,3,4];
      selectedPlayerCount = mapping[Math.max(0, Math.min(2, idxBtn))];
      drawImmediate(); return;
    }
    const createBtn = sRect(380,120,140,40);
    if (mx >= createBtn.x && mx <= createBtn.x + createBtn.w && my >= createBtn.y && my <= createBtn.y + createBtn.h) {
      if (!ws_client.connected) { try { await ws_client.connect(); } catch(e){ console.error('connect failed', e); return; } }
      ws_client.send({ type: 'create', room: input_room, name: input_name, playerCount: selectedPlayerCount });
      return;
    }
    const joinBtn = sRect(380,180,140,40);
    if (mx >= joinBtn.x && mx <= joinBtn.x + joinBtn.w && my >= joinBtn.y && my <= joinBtn.y + joinBtn.h) {
      if (!ws_client.connected) { try { await ws_client.connect(); } catch(e){ console.error('connect failed', e); return; } }
      ws_client.send({ type: 'join', room: input_room, name: input_name });
      return;
    }
    const startBtn = sRect(800,120,140,40);
    if (is_host && room_chosen && mx >= startBtn.x && mx <= startBtn.x + startBtn.w && my >= startBtn.y && my <= startBtn.y + startBtn.h) {
      ws_client.send({ type: 'start', room: room_chosen });
      return;
    }
    // server list join buttons
    for (let i=0;i<serversButtonRects.length;i++){
      const r = serversButtonRects[i];
      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        const roomId = servers[i].id;
        if (!ws_client.connected) { try { await ws_client.connect(); } catch (e) { console.error('connect failed', e); return; } }
        ws_client.send({ type: 'join', room: roomId, name: input_name });
        return;
      }
    }
    return;
  }

  // Gameplay: first check claim UI overlaps (if in claimMode)
  if (claimMode) {
    // check candidate hits
    for (const r of claimRects) {
      if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
        // toggle selection for this triangle
        if (selectedClaimKeys.has(r.key)) selectedClaimKeys.delete(r.key);
        else selectedClaimKeys.add(r.key);
        drawImmediate();
        return;
      }
    }
    // check claim button
    if (claimButtonRect && mx >= claimButtonRect.x && mx <= claimButtonRect.x + claimButtonRect.w && my >= claimButtonRect.y && my <= claimButtonRect.y + claimButtonRect.h) {
      // prepare triangles as arrays
      const triangles = [];
      for (const c of claimCandidates) {
        if (selectedClaimKeys.has(c.key)) triangles.push(c.points.slice());
      }
      if (triangles.length === 0) { /* nothing to send */ return; }
      if (ws_client.connected && room_chosen !== null) {
        waiting_for_server = true;
        ws_client.send({ type: 'claim_triangles', room: room_chosen, triangles });
      } else {
        // local mode: validate and accept
        localAcceptClaims(triangles);
      }
      drawImmediate();
      return;
    }
    // check end turn button
    if (endTurnRect && mx >= endTurnRect.x && mx <= endTurnRect.x + endTurnRect.w && my >= endTurnRect.y && my <= endTurnRect.y + endTurnRect.h) {
      if (ws_client.connected && room_chosen !== null) {
        waiting_for_server = true;
        ws_client.send({ type: 'end_turn', room: room_chosen });
      } else {
        // local: clear claimMode and advance turn
        claimMode = false; selectedClaimKeys.clear();
        next_turn_local_scaled();
      }
      drawImmediate();
      return;
    }
    // fallthrough: if clicked elsewhere while claimMode -> ignore for making new lines
    // (player must end turn before next line)
    return;
  }

  // normal gameplay line drawing (when not in claimMode)
  if (animating || waiting_for_server) return;
  if (game_over) return;
  if (score[turn] >= 15 || moves[turn] <= 0) { next_turn_local_scaled(); return; }
  const i = nearScaled([mx, my]);
  if (i !== null) {
    if (sel === null) { sel = i; drag_pos = [mx,my]; drawImmediate(); return; }
    else if (i !== sel) {
      const path = line_ok_scaled(sel, i);
      if (path.length === STEP_POINTS) {
        let made_line=false;
        for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge=sortedPair(a,b); if (!con.find(e=>e[0]===edge[0] && e[1]===edge[1])) made_line=true; }
        if (made_line) {
          if (ws_client.connected && room_chosen !== null) {
            waiting_for_server = true;
            // mark that we want to claim after server ack
            claimMode = true;
            selectedClaimKeys.clear();
            ws_client.send({ type: 'make_move', room: room_chosen, path: path });
          } else {
            // local: add edges, enable claimMode (manual)
            for (let k=0;k<path.length-1;k++){ const a=path[k], b=path[k+1]; const edge=sortedPair(a,b); if (!con.find(e=>e[0]===edge[0] && e[1]===edge[1])) con.push(edge); }
            // enable claim mode locally
            claimMode = true; selectedClaimKeys.clear();
            updateClaimCandidates();
            drawImmediate();
          }
        }
      }
      sel=null; drag_pos=null; drawImmediate();
    }
  }
}

function handlePointerMove(clientX, clientY) {
  const pos = canvasPosFromEvent(clientX, clientY);
  const mx = pos.x, my = pos.y;
  if (sel !== null && !animating && !waiting_for_server) { drag_pos = [mx,my]; drawImmediate(); }
}

canvas.addEventListener('mousedown', (ev) => { handlePointerDown(ev.clientX, ev.clientY); });
canvas.addEventListener('mousemove', (ev) => { handlePointerMove(ev.clientX, ev.clientY); });

canvas.addEventListener('touchstart', (ev) => { ev.preventDefault(); const t = ev.touches[0]; if (!t) return; handlePointerDown(t.clientX, t.clientY); });
canvas.addEventListener('touchmove', (ev) => { ev.preventDefault(); const t = ev.touches[0]; if (!t) return; handlePointerMove(t.clientX, t.clientY); });
canvas.addEventListener('touchend', (ev) => { if (sel !== null) { sel=null; drag_pos=null; drawImmediate(); } });

window.addEventListener('keydown', (ev) => {
  if (room_chosen === null && con.length === 0 && tris.length === 0 && input_active) {
    if (ev.key === 'Backspace') {
      if (input_active === 'name') input_name = input_name.slice(0,-1);
      else input_room = input_room.slice(0,-1);
    } else if (ev.key === 'Enter') input_active = null;
    else if (ev.key.length === 1) { if (input_active === 'name') input_name += ev.key; else input_room += ev.key; }
    drawImmediate();
  }
});

function drawLobbyUI() {
  ctx.fillStyle = '#1e1e24'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
  ctx.font = `${Math.max(18, Math.round(36*scale))}px Arial`; ctx.fillStyle='#fff';
  const title='Lobby'; const titleW = ctx.measureText(title).width; ctx.fillText(title, (canvas.clientWidth-titleW)/2, sy(20));

  const nameBox = sRect(50,120,300,40);
  roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, true, '#32323c');
  ctx.lineWidth = Math.max(1, Math.round(2*scale)); ctx.strokeStyle = '#c8c8c8'; roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, false);
  ctx.fillStyle='#fff'; ctx.font = FONT; ctx.fillText('Name: '+input_name, nameBox.x + sx(10), nameBox.y + sy(8));

  const roomBox = sRect(50,180,300,40);
  roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, true, '#32323c'); roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, false);
  ctx.fillStyle='#fff'; ctx.fillText('Room: '+input_room, roomBox.x + sx(10), roomBox.y + sy(8));

  const counts = [2,3,4];
  for (let i=0;i<counts.length;i++){
    const x = sx(520) + i * Math.round((66 + 6) * scale);
    const y = sy(120);
    const wRect = Math.round(66 * scale), hRect = Math.round(36 * scale);
    roundRectLocal(ctx, x, y, wRect, hRect, 6, true, (counts[i] === selectedPlayerCount) ? '#3cc078' : '#444');
    ctx.fillStyle = (counts[i] === selectedPlayerCount) ? '#000' : '#fff';
    ctx.font = FONT;
    ctx.fillText(String(counts[i]), x + wRect/2 - ctx.measureText(String(counts[i])).width/2, y + Math.round(6*scale));
  }

  const createBtn = sRect(380,120,140,40);
  const joinBtn = sRect(380,180,140,40);
  roundRectLocal(ctx, createBtn.x, createBtn.y, createBtn.w, createBtn.h, 6, true, '#4682b4');
  roundRectLocal(ctx, joinBtn.x, joinBtn.y, joinBtn.w, joinBtn.h, 6, true, '#4682b4');
  ctx.fillStyle='#fff'; ctx.font = FONT; ctx.fillText('Create', createBtn.x + sx(25), createBtn.y + sy(8));
  ctx.fillText('Join', joinBtn.x + sx(35), joinBtn.y + sy(8));

  ctx.fillStyle='#fff'; ctx.fillText('Players in room:', sx(50), sy(250));
  let y = sy(290); ctx.font = FONT;
  for (const p of lobby_players) { const flag = p.isHost ? ' (host)' : ''; ctx.fillStyle = '#e6e6e6'; ctx.fillText(`${p.index + 1}. ${p.name}${flag}`, sx(60), y); y += sy(30); }

  if (is_host && room_chosen) { roundRectLocal(ctx, sx(800), sy(120), sx(140), sy(40), 6, true, '#3cc078'); ctx.fillStyle='#000'; ctx.fillText('Start', sx(830), sy(128)); }

  ctx.fillStyle='#fff'; ctx.fillText('Servers:', sx(520), sy(220)); serversButtonRects = [];
  let syPos = sy(260); ctx.font = `${Math.max(10, Math.round(14*scale))}px Arial`;
  for (let i=0;i<servers.length;i++){
    const sRow = servers[i];
    const rx = sx(520), rw = Math.round(440 * scale), rh = Math.round(40 * scale);
    roundRectLocal(ctx, rx, syPos, rw, rh, 6, true, '#2a2a33');
    ctx.fillStyle = '#fff';
    const label = `${sRow.id} ‚Äî players: ${sRow.players}/${sRow.maxPlayers} ${sRow.started ? '[started]' : ''}`;
    ctx.fillText(label, rx + sx(10), syPos + Math.round(10 * scale));
    const bx = rx + rw - Math.round(80 * scale), by = syPos + Math.round(6 * scale), bw = Math.round(70 * scale), bh = Math.round(28 * scale);
    roundRectLocal(ctx, bx, by, bw, bh, 6, true, '#4682b4');
    ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Join', bx + Math.round(18 * scale), by + Math.round(4 * scale));
    serversButtonRects.push({ x: bx, y: by, w: bw, h: bh });
    syPos += Math.round(54 * scale);
    if (syPos > canvas.clientHeight - Math.round(80 * scale)) break;
  }

  if (input_active) {
    // draw simple keyboard if needed (your existing keyboard code can remain)
    // but keyboard code omitted here for brevity ‚Äî you already have it above in previous iterations
  }
  ctx.font = FONT;
}

///// Main loop
async function mainLoop() {
  try { await handle_server_messages(); } catch(e) {}
  if (room_chosen === null && con.length === 0 && tris.length === 0) {
    drawLobbyUI();
  } else {
    drawFrame(sel, drag_pos);
  }
  requestAnimationFrame(mainLoop);
}
requestAnimationFrame(mainLoop);

(async ()=> { try { await ws_client.connect(); requestRoomsList(); } catch(e) { console.warn('initial ws connect failed', e); } })();
setInterval(()=>{ if (ws_client.connected && room_chosen === null) requestRoomsList(); }, 5000);

function logState(){ console.log({ con, tris, score, moves, turn, room_chosen, player_index, servers, playerNames, claimMode }); }

</script>
</body>
</html>
