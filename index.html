<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <!-- mobile-friendly viewport, lock zoom so game remains usable -->
  <!-- Fullscreen and portrait lock -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="full-screen" content="yes">
  <meta name="screen-orientation" content="portrait">

  <title>Hex Game ‚Äî Multiplayer (Mobile)</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #14151a;
      font-family: Arial, Helvetica, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100vw;
      height: 100dvh;
      padding: 0;
    }

    #game {
      display: block;
      background: #1e1f29;
      width: 100%;
      height: 100%;
      touch-action: none;
      border: none;
      margin: 0;
      padding: 0;
    }

    .note {
      position: fixed;
      left: 8px;
      bottom: 8px;
      color: #ccc;
      font-size: 12px
    }
  </style>
</head>

<body>
  <div class="wrap">
    <canvas id="game"></canvas>
  </div>
  <div class="note">Mobile-first layout ‚Äî tap dots to play. Run server.js and open this page.</div>

  <script>
    /*
     Mobile-first Hex Game client (updated to show nicknames in player panels)
     Added: on-screen custom keyboard (touch/click) for Name and Room editing
    */

    ///// CONFIG - keep these logical values but they will be scaled to screen
    const LOGICAL_BASE_W = 1000;
    const LOGICAL_BASE_H = 700;
    const BASE_SP = 60;
    const BASE_DR = 10;
    const BASE_FONT_PX = 22;
    const BASE_BIG_FONT_PX = 64;

    const R = 4;
    const STEP_POINTS = 4; // required path length
    const DEFAULT_MOVES = 15;

    ///// Networking
    const WS_URL = 'wss://frosty-colden.185-234-114-50.plesk.page';

    ///// DOM + canvas setup (responsive)
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });

    function setupCanvasSize() {
      const DPR = window.devicePixelRatio || 1;

      // Fullscreen
      const cssWidth = window.innerWidth;
      const cssHeight = window.innerHeight;

      canvas.style.width = cssWidth + 'px';
      canvas.style.height = cssHeight + 'px';
      canvas.width = Math.round(cssWidth * DPR);
      canvas.height = Math.round(cssHeight * DPR);

      WIDTH = cssWidth;
      HEIGHT = cssHeight;

      // scale grid relative to smallest screen dimension
      scale = Math.min(WIDTH / LOGICAL_BASE_W, HEIGHT / LOGICAL_BASE_H);
      DPR_SCALE = DPR;

      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

      SP = Math.max(12, Math.round(BASE_SP * scale));
      DR = Math.max(6, Math.round(BASE_DR * scale));
      FONT = `${Math.max(10, Math.round(BASE_FONT_PX * scale))}px Arial`;
      BIG_FONT = `${Math.min(48, Math.max(24, Math.round(BASE_BIG_FONT_PX * Math.max(0.6, scale))))}px Arial`;
      LINE_THICKNESS = Math.max(2, Math.round(4 * scale));
    }
    window.addEventListener('resize', () => { setupCanvasSize(); drawImmediate(); });
    setupCanvasSize();
    window.addEventListener('resize', () => { setupCanvasSize(); drawImmediate(); });

    ///// Colors
    const BG = '#14171b';
    const DOT = '#222629';
    const LINE_COLOR = '#ffffff';
    const PLAYERS_COLORS = ['#ff0000', '#ffff00', '#00ff00', '#0000ff'];

    ///// Grid (rebuild using dynamic SP / scale)
    const pts = [];
    const idx = {};
    function buildGrid() {
      pts.length = 0;
      for (let q = -R + 1; q < R; q++) {
        const r1 = Math.max(-R + 1, -q - R + 1);
        const r2 = Math.min(R - 1, -q + R - 1);
        for (let rr = r1; rr <= r2; rr++) {
          const pos = toxy(q, rr);
          idx[`${q},${rr}`] = pts.length;
          pts.push({ pos, q, r: rr });
        }
      }
    }
    function toxy(q, r) {
      const x = SP * (1.5 * q);
      const y = SP * (Math.sqrt(3) * (r + q / 2));
      const cssW = canvas.clientWidth;
      const cssH = canvas.clientHeight;
      // center and a small dynamic vertical offset
      return [Math.round(x + cssW / 2), Math.round(y + cssH / 2 + Math.max(20 * scale, 10))];
    }
    buildGrid();

    ///// Game state
    let con = [];
    let tris = [];
    let sel = null, turn = 0;
    let moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES];
    let score = [0, 0, 0, 0];
    let game_over = false, winner = null;
    let tri_delay = Math.max(120, Math.round(400 * scale));
    let animating = false, waiting_for_server = false;

    ///// Lobby & UI state
    let room_chosen = null, player_index = null, is_host = false, lobby_players = [];
    let input_active = null, input_name = 'Player', input_room = 'room1';
    let selectedPlayerCount = 4;
    let servers = [];
    let serversButtonRects = [];
    let showWinnerOverlay = false;
    let winnerOverlayData = null;
    let winnerOverlayTimeout = null;

    // ---------- NEW: playerNames array (index -> nickname) ----------
    let playerNames = []; // will be populated from server messages (playerNames array or lobby players)

    // ---------- NEW: on-screen keyboard state ----------
    let keyboardRects = []; // [{x,y,w,h,key}]
    const MAX_INPUT_LENGTH = 20;

    /* scaled helpers */
    function sx(x) { return Math.round(x * scale); }
    function sy(y) { return Math.round(y * scale); }
    function sRect(x, y, w, h) { return { x: sx(x), y: sy(y), w: Math.round(w * scale), h: Math.round(h * scale) }; }

    function drawHexagonLocal(ctx, color, center, radius, fill = true, width = 0) {
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const ang = (Math.PI / 180) * (60 * i - 30);
        const x = center[0] + radius * Math.cos(ang);
        const y = center[1] + radius * Math.sin(ang);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.closePath();
      if (fill) { ctx.fillStyle = color; ctx.fill(); }
      if (width > 0) { ctx.lineWidth = width; ctx.strokeStyle = LINE_COLOR; ctx.stroke(); }
    }

    function drawLineLocal(ctx, a, b, thickness = LINE_THICKNESS) {
      ctx.beginPath(); ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]); ctx.lineWidth = thickness; ctx.strokeStyle = LINE_COLOR; ctx.stroke();
    }

    function roundRectLocal(ctx, x, y, w, h, r, fill = false, fillStyle = '#000') {
      ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath();
      if (fill) { ctx.fillStyle = fillStyle; ctx.fill(); }
      else ctx.stroke();
    }

    function shadeColor(hex, amt) {
      const c = hex.replace('#', '');
      const num = parseInt(c, 16);
      let r = (num >> 16) + amt; if (r > 255) r = 255; if (r < 0) r = 0;
      let g = ((num >> 8) & 0x00FF) + amt; if (g > 255) g = 255; if (g < 0) g = 0;
      let b = (num & 0x0000FF) + amt; if (b > 255) b = 255; if (b < 0) b = 0;
      return `rgb(${r},${g},${b})`;
    }

    // ---------- UPDATED: drawPlayerPanels shows nicknames ----------
    function drawPlayerPanels() {
      // responsive box sizes
      const pad = Math.max(6, sx(6));
      const box_w = Math.min(sx(220), Math.round(canvas.clientWidth * 0.45));
      const box_h = Math.min(sy(80), Math.round(canvas.clientHeight * 0.16));
      const positions = [
        [pad, pad],
        [canvas.clientWidth - box_w - pad, pad],
        [pad, canvas.clientHeight - box_h - pad],
        [canvas.clientWidth - box_w - pad, canvas.clientHeight - box_h - pad]
      ];
      ctx.font = FONT; ctx.textBaseline = 'top';
      for (let i = 0; i < 4; i++) {
        const [x, y] = positions[i];
        const color = PLAYERS_COLORS[i];
        const active = (i === turn);
        const disabled = (score[i] >= 15 || moves[i] <= 0);
        const rect_color = disabled ? '#3c3c46' : (active ? shadeColor(color, 40) : '#323238');
        roundRectLocal(ctx, x, y, box_w, box_h, 10, true, rect_color);
        ctx.lineWidth = Math.max(1, Math.round(3 * scale)); ctx.strokeStyle = color; roundRectLocal(ctx, x, y, box_w, box_h, 10, false);
        ctx.fillStyle = '#fff';

        // get the display name (prefer playerNames, fallback to lobby_players name, fallback to P#)
        let displayName = null;
        if (Array.isArray(playerNames) && playerNames[i]) displayName = playerNames[i];
        else {
          const p = lobby_players.find(pp => pp.index === i);
          if (p && p.name) displayName = p.name;
        }
        if (!displayName) displayName = `P${i + 1}`;
        // clamp length
        const shortName = displayName.length > 14 ? displayName.slice(0, 13) + '‚Ä¶' : displayName;

        ctx.font = `${Math.max(10, Math.round(16 * scale))}px Arial`;
        ctx.fillText(shortName, x + sx(10), y + sy(8));
        ctx.font = `${Math.max(10, Math.round(14 * scale))}px Arial`;
        ctx.fillText(`Score: ${score[i]}`, x + sx(10), y + sy(34));
        ctx.fillText(`Moves: ${moves[i]}`, x + sx(110), y + sy(34));
      }
    }

    function drawFrame(sel_local = null, dragPos = null, temp_centers = null) {
      ctx.fillStyle = BG; ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      // edges
      ctx.lineWidth = LINE_THICKNESS; ctx.strokeStyle = LINE_COLOR;
      for (const [a, b] of con) { drawLineLocal(ctx, pts[a].pos, pts[b].pos, LINE_THICKNESS); }

      // triangles -> small dot center
      for (const tri of tris) {
        try {
          const ptsList = tri.points.map(i => pts[i].pos);
          const color = PLAYERS_COLORS[tri.owner] || PLAYERS_COLORS[0];
          const cx = (ptsList[0][0] + ptsList[1][0] + ptsList[2][0]) / 3;
          const cy = (ptsList[0][1] + ptsList[1][1] + ptsList[2][1]) / 3;
          drawHexagonLocal(ctx, color, [cx, cy], Math.max(6, Math.round(8 * scale)), true);
        } catch (e) { }
      }

      // temp centers
      if (temp_centers) {
        for (const [center, color] of temp_centers) { drawHexagonLocal(ctx, color, center, Math.max(8, Math.round(10 * scale)), true); }
      }

      // points
      for (const p of pts) { drawHexagonLocal(ctx, DOT, p.pos, Math.max(4, Math.round(DR)), true); }

      // dragging preview
      if (sel_local !== null && dragPos) { drawLineLocal(ctx, pts[sel_local].pos, dragPos, LINE_THICKNESS); }

      // player panels (uses nicknames)
      drawPlayerPanels();

      // winner overlay (if present)
      if (showWinnerOverlay && winnerOverlayData) {
        ctx.fillStyle = 'rgba(0,0,0,0.86)'; ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
        ctx.font = `bold ${Math.max(18, Math.round(28 * scale))}px Arial`; ctx.fillStyle = '#fff';
        const winnerNameText = winnerOverlayData.winnerName || (typeof winner === 'number' && playerNames[winner] ? playerNames[winner] : ('P' + ((winner || 0) + 1)));
        const text = `${winnerOverlayData.emoji || 'üèÜ'}  –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winnerNameText}`;
        const w = ctx.measureText(text).width;
        ctx.fillText(text, (canvas.clientWidth - w) / 2, canvas.clientHeight / 2 - 12 * scale);
      }
    }

    function drawImmediate() { drawFrame(sel, drag_pos); }

    function nearScaled(pos) {
      const hitR = Math.max(18, Math.round((DR + 8) * Math.max(1, 1 / scale)));
      for (let i = 0; i < pts.length; i++) {
        const p = pts[i].pos; const dx = p[0] - pos[0], dy = p[1] - pos[1];
        if (dx * dx + dy * dy <= hitR * hitR) return i;
      }
      return null;
    }

    function sortedPair(a, b) { return a < b ? [a, b] : [b, a]; }

    function line_ok_scaled(a, b) {
      const p1 = pts[a], p2 = pts[b];
      const q1 = p1.q, r1 = p1.r, q2 = p2.q, r2 = p2.r;
      const d = Math.max(Math.abs(q1 - q2), Math.abs(r1 - r2), Math.abs((q1 + r1) - (q2 + r2)));
      if (d === 0) return [];
      if (!((q1 - q2 === 0) || (r1 - r2 === 0) || ((q1 + r1) - (q2 + r2) === 0))) return [];
      const dq = (q2 - q1) / d, dr = (r2 - r1) / d;
      const path = [];
      for (let i = 0; i <= d; i++) {
        const q = Math.round(q1 + dq * i), r = Math.round(r1 + dr * i);
        const key = `${q},${r}`;
        if (key in idx) path.push(idx[key]); else return [];
      }
      return path;
    }

    function find_triangles_local_scaled() {
      const found = [];
      const edgesSet = new Set(con.map(e => `${e[0]}-${e[1]}`));
      const n = pts.length;
      for (let a = 0; a < n; a++) {
        for (let b = a + 1; b < n; b++) {
          if (!edgesSet.has(`${a}-${b}`)) continue;
          for (let c = b + 1; c < n; c++) {
            if (edgesSet.has(`${b}-${c}`) && edgesSet.has(`${a}-${c}`)) found.push([a, b, c]);
          }
        }
      }
      return found;
    }

    function tri_center_scaled(tri_pts) {
      const xs = tri_pts.map(p => p[0]); const ys = tri_pts.map(p => p[1]);
      return [Math.floor((xs[0] + xs[1] + xs[2]) / 3), Math.floor((ys[0] + ys[1] + ys[2]) / 3)];
    }

    function end_if_needed_scaled() {
      const active_players = [];
      for (let i = 0; i < 4; i++) if (moves[i] > 0 && score[i] < 15) active_players.push(i);
      if (active_players.length <= 1) { game_over = true; winner = score.indexOf(Math.max(...score)); return true; }
      return false;
    }

    function next_turn_local_scaled() {
      for (let i = 0; i < 4; i++) { turn = (turn + 1) % 4; if (moves[turn] > 0 && score[turn] < 15) break; }
    }

    async function animateTriangleCentersScaled(new_tris_list) {
      animating = true;
      const temp = [];
      for (const item of new_tris_list) {
        temp.push([item.center, item.color]);
        drawFrame(null, null, temp);
        await new Promise(r => setTimeout(r, Math.max(80, tri_delay)));
      }
      animating = false;
    }

    ///// WebSocket client
    class WSClient {
      constructor(url) { this.url = url; this.ws = null; this.queue = []; this.connected = false; }
      connect() {
        return new Promise((res, rej) => {
          try {
            this.ws = new WebSocket(this.url);
            this.ws.addEventListener('open', () => { this.connected = true; console.log('WS open'); res(); });
            this.ws.addEventListener('message', e => { try { const d = JSON.parse(e.data); this.queue.push(d); console.log('SERVER MSG:', d); } catch (err) { } });
            this.ws.addEventListener('close', () => { this.connected = false; this.queue.push({ type: 'closed' }); console.log('WS closed'); });
            this.ws.addEventListener('error', (err) => { console.error('WS error', err); });
          } catch (e) { rej(e); }
        });
      }
      send(obj) { if (this.ws && this.connected) this.ws.send(JSON.stringify(obj)); }
      recv_nowait() { return this.queue.length ? this.queue.shift() : null; }
    }
    const ws_client = new WSClient(WS_URL);

    function requestRoomsList() { if (ws_client.connected) ws_client.send({ type: 'list_rooms' }); }

    // ---------- UPDATED: handle_server_messages sets playerNames ----------
    async function handle_server_messages() {
      const data = ws_client.recv_nowait(); if (!data) return;
      const t = data.type;

      if (t === 'created') {
        room_chosen = data.room; player_index = data.playerIndex;
        // server may include playerName
        if (typeof data.playerName !== 'undefined') {
          playerNames = playerNames.slice(); playerNames[player_index] = data.playerName;
        }
        console.log('created', room_chosen, player_index);
      }
      else if (t === 'joined') {
        room_chosen = data.room; player_index = data.playerIndex;
        if (typeof data.playerName !== 'undefined') {
          playerNames = playerNames.slice(); playerNames[player_index] = data.playerName;
        }
        console.log('joined', room_chosen, player_index);
      }
      else if (t === 'lobby') {
        lobby_players = data.players || [];
        // build/merge playerNames from lobby list
        const maxIdx = Math.max(4, ...(lobby_players.map(p => p.index)));
        playerNames = Array(maxIdx + 1).fill(null);
        for (const p of lobby_players) playerNames[p.index] = p.name;
        const hostIndex = (typeof data.hostIndex !== 'undefined') ? data.hostIndex : 0;
        is_host = (player_index === hostIndex);
      }
      else if (t === 'start') {
        con = []; tris = [];
        score = Array.isArray(data.score) ? data.score : score;
        moves = Array.isArray(data.moves) ? data.moves : moves;
        turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
        game_over = false; winner = null; waiting_for_server = false;
        // prefer explicit playerNames array, or fallback to players array
        if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
        else if (Array.isArray(data.players)) {
          playerNames = Array(Math.max(4, data.players.length)).fill(null);
          for (const p of data.players) playerNames[p.index] = p.name;
        }
      }
      else if (t === 'state_update') {
        try { con = (data.con || []).map(pair => [pair[0], pair[1]]); } catch (e) { con = []; }
        if (Array.isArray(data.tris)) {
          tris = data.tris.map(tr => ({ points: tr.points.slice(), owner: tr.owner }));
        } else {
          const new_tris = data.new_tris || [];
          for (const tr of new_tris) {
            const pts_trip = tr.points.slice();
            const owner = tr.owner;
            if (!tris.find(t => arraysEqual(t.points.slice().sort(), pts_trip.slice().sort()))) {
              tris.push({ points: pts_trip, owner });
            }
          }
        }
        score = Array.isArray(data.score) ? data.score : score;
        moves = Array.isArray(data.moves) ? data.moves : moves;
        turn = (typeof data.turn !== 'undefined') ? data.turn : turn;
        game_over = (typeof data.game_over !== 'undefined') ? data.game_over : game_over;
        winner = (typeof data.winner !== 'undefined') ? data.winner : winner;
        waiting_for_server = false;
        // update playerNames if server provided
        if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
        else if (Array.isArray(data.players)) {
          playerNames = Array(Math.max(4, data.players.length)).fill(null);
          for (const p of data.players) playerNames[p.index] = p.name;
        }
      }
      else if (t === 'rooms_list') { servers = Array.isArray(data.rooms) ? data.rooms : []; }
      else if (t === 'game_over') {
        showWinnerOverlay = true;
        winnerOverlayData = { winnerName: data.winnerName || null, emoji: data.emoji || 'üèÜ' };
        // if server didn't include winnerName, try to fill from playerNames[winner]
        if (!winnerOverlayData.winnerName && typeof data.winner === 'number' && playerNames[data.winner]) {
          winnerOverlayData.winnerName = playerNames[data.winner];
        }
        if (winnerOverlayTimeout) clearTimeout(winnerOverlayTimeout);
        winnerOverlayTimeout = setTimeout(() => { showWinnerOverlay = false; winnerOverlayData = null; room_chosen = null; player_index = null; lobby_players = []; con = []; tris = []; score = [0, 0, 0, 0]; moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES]; requestRoomsList(); }, 3000);
      }
      else if (t === 'closed') { console.log('server closed connection'); }
      else if (t === 'error') { console.warn('server error:', data.message); }
    }

    function arraysEqual(a, b) { if (a.length !== b.length) return false; for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false; return true; }

    ///// Pointer handling
    let drag_pos = null;

    function canvasPosFromEvent(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const DPR = window.devicePixelRatio || 1;
      // convert to CSS coords that match drawing coordinates used elsewhere
      const x = Math.round((clientX - rect.left));
      const y = Math.round((clientY - rect.top));
      return { x, y };
    }

    // ---------- NEW: draw on-screen keyboard ----------
    function drawKeyboard() {
      keyboardRects = [];
      if (!input_active) return;

      // Simple layout: 3 rows of letters + one control row (SPACE BACKSPACE ENTER)
      const rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'];
      const margin = Math.max(8, sx(8));
      const kbHeight = Math.min(Math.round(canvas.clientHeight * 0.32), sy(220));
      const kbTop = canvas.clientHeight - kbHeight - margin - sy(20); // move up by 20 logical units

      // background
      roundRectLocal(ctx, margin, kbTop, canvas.clientWidth - margin * 2, kbHeight, 12, true, '#1b1b1f');

      // draw rows
      const rowHeight = Math.round((kbHeight - margin * 3) / 4);
      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        const y = kbTop + margin + r * (rowHeight + margin / 2);
        const keyW = Math.floor((canvas.clientWidth - margin * 4) / row.length) - 6;
        for (let k = 0; k < row.length; k++) {
          const key = row[k];
          const x = margin * 2 + k * (keyW + 6);
          const w = keyW; const h = rowHeight;
          roundRectLocal(ctx, x, y, w, h, 6, true, '#2a2a33');
          ctx.fillStyle = '#fff'; ctx.font = `${Math.max(12, Math.round(16 * scale))}px Arial`;
          const tw = ctx.measureText(key).width;
          ctx.fillText(key, x + (w - tw) / 2, y + Math.round((h - parseInt(ctx.font, 10)) / 2));
          keyboardRects.push({ x: Math.round(x), y: Math.round(y), w: Math.round(w), h: Math.round(h), key });
        }
      }

      // control row
      const ctrlY = kbTop + margin + rows.length * (rowHeight + margin / 2);
      const spaceW = Math.round((canvas.clientWidth - margin * 6) * 0.55);
      const otherW = Math.round((canvas.clientWidth - margin * 6 - spaceW) / 2);
      const spaceX = margin * 2;
      // SPACE
      roundRectLocal(ctx, spaceX, ctrlY, spaceW, rowHeight, 8, true, '#3c3c46');
      ctx.fillStyle = '#fff'; ctx.font = `${Math.max(12, Math.round(16 * scale))}px Arial`;
      const spaceLabel = 'SPACE';
      ctx.fillText(spaceLabel, spaceX + (spaceW - ctx.measureText(spaceLabel).width) / 2, ctrlY + Math.round((rowHeight - parseInt(ctx.font, 10)) / 2));
      keyboardRects.push({ x: Math.round(spaceX), y: Math.round(ctrlY), w: Math.round(spaceW), h: Math.round(rowHeight), key: ' ' });

      // BACKSPACE
      const backX = spaceX + spaceW + 6;
      roundRectLocal(ctx, backX, ctrlY, otherW, rowHeight, 8, true, '#d9534f');
      ctx.fillStyle = '#fff';
      const backLabel = 'BACK';
      ctx.fillText(backLabel, backX + (otherW - ctx.measureText(backLabel).width) / 2, ctrlY + Math.round((rowHeight - parseInt(ctx.font, 10)) / 2));
      keyboardRects.push({ x: Math.round(backX), y: Math.round(ctrlY), w: Math.round(otherW), h: Math.round(rowHeight), key: 'BACK' });

      // ENTER
      const enterX = backX + otherW + 6;
      roundRectLocal(ctx, enterX, ctrlY, otherW, rowHeight, 8, true, '#3cc078');
      ctx.fillStyle = '#000';
      const enterLabel = 'ENTER';
      ctx.fillText(enterLabel, enterX + (otherW - ctx.measureText(enterLabel).width) / 2, ctrlY + Math.round((rowHeight - parseInt(ctx.font, 10)) / 2));
      keyboardRects.push({ x: Math.round(enterX), y: Math.round(ctrlY), w: Math.round(otherW), h: Math.round(rowHeight), key: 'ENTER' });
    }

    function handleVirtualKey(key) {
      if (!input_active) return;
      if (key === 'BACK') {
        if (input_active === 'name') input_name = input_name.slice(0, -1);
        else input_room = input_room.slice(0, -1);
      } else if (key === 'ENTER') {
        input_active = null;
      } else {
        // character (space or letter)
        if (input_active === 'name') {
          if (input_name.length < MAX_INPUT_LENGTH) input_name += key;
        } else {
          if (input_room.length < MAX_INPUT_LENGTH) input_room += key;
        }
      }
      drawImmediate();
    }

    async function handlePointerDown(clientX, clientY) {
      const pos = canvasPosFromEvent(clientX, clientY);
      const mx = pos.x, my = pos.y;
      // lobby hit handling...
      if (room_chosen === null && con.length === 0 && tris.length === 0) {
        // if keyboard visible - check keyboard hits first
        if (input_active && keyboardRects.length) {
          for (const r of keyboardRects) {
            if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
              handleVirtualKey(r.key);
              return;
            }
          }
        }

        const nameBox = sRect(50, 120, 300, 40);
        if (mx >= nameBox.x && mx <= nameBox.x + nameBox.w && my >= nameBox.y && my <= nameBox.y + nameBox.h) { input_active = 'name'; drawImmediate(); return; }
        const roomBox = sRect(50, 180, 300, 40);
        if (mx >= roomBox.x && mx <= roomBox.x + roomBox.w && my >= roomBox.y && my <= roomBox.y + roomBox.h) { input_active = 'room'; drawImmediate(); return; }

        const pcRegion = sRect(520, 120, 66 * 3 + 6 * 2, 36);
        if (mx >= pcRegion.x && mx <= pcRegion.x + pcRegion.w && my >= pcRegion.y && my <= pcRegion.y + pcRegion.h) {
          const relative = mx - pcRegion.x;
          const idxBtn = Math.floor(relative / Math.round(66 * scale));
          const mapping = [2, 3, 4];
          selectedPlayerCount = mapping[Math.max(0, Math.min(2, idxBtn))];
          drawImmediate(); return;
        }

        const createBtn = sRect(380, 120, 140, 40);
        if (mx >= createBtn.x && mx <= createBtn.x + createBtn.w && my >= createBtn.y && my <= createBtn.y + createBtn.h) {
          if (!ws_client.connected) { try { await ws_client.connect(); } catch (e) { console.error('connect failed', e); return; } }
          ws_client.send({ type: 'create', room: input_room, name: input_name, playerCount: selectedPlayerCount });
          return;
        }

        const joinBtn = sRect(380, 180, 140, 40);
        if (mx >= joinBtn.x && mx <= joinBtn.x + joinBtn.w && my >= joinBtn.y && my <= joinBtn.y + joinBtn.h) {
          if (!ws_client.connected) { try { await ws_client.connect(); } catch (e) { console.error('connect failed', e); return; } }
          ws_client.send({ type: 'join', room: input_room, name: input_name });
          return;
        }

        const startBtn = sRect(800, 120, 140, 40);
        if (is_host && room_chosen && mx >= startBtn.x && mx <= startBtn.x + startBtn.w && my >= startBtn.y && my <= startBtn.y + startBtn.h) {
          ws_client.send({ type: 'start', room: room_chosen });
          return;
        }

        for (let i = 0; i < serversButtonRects.length; i++) {
          const r = serversButtonRects[i];
          if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
            const roomId = servers[i].id;
            if (!ws_client.connected) { try { await ws_client.connect(); } catch (e) { console.error('connect failed', e); return; } }
            ws_client.send({ type: 'join', room: roomId, name: input_name });
            return;
          }
        }

        return;
      }

      // gameplay
      if (animating || waiting_for_server) return;
      if (game_over) return;
      if (score[turn] >= 15 || moves[turn] <= 0) { next_turn_local_scaled(); return; }
      const i = nearScaled([mx, my]);
      if (i !== null) {
        if (sel === null) { sel = i; drag_pos = [mx, my]; drawImmediate(); return; }
        else if (i !== sel) {
          const path = line_ok_scaled(sel, i);
          if (path.length === STEP_POINTS) {
            let made_line = false;
            for (let k = 0; k < path.length - 1; k++) { const a = path[k], b = path[k + 1]; const edge = sortedPair(a, b); if (!con.find(e => e[0] === edge[0] && e[1] === edge[1])) made_line = true; }
            if (made_line) {
              if (ws_client.connected && room_chosen !== null) { waiting_for_server = true; try { ws_client.send({ type: 'make_move', room: room_chosen, path: path }); } catch (err) { console.error('send move failed', err); waiting_for_server = false; } }
              else {
                for (let k = 0; k < path.length - 1; k++) { const a = path[k], b = path[k + 1]; const edge = sortedPair(a, b); if (!con.find(e => e[0] === edge[0] && e[1] === edge[1])) con.push(edge); }
                const all_tris = find_triangles_local_scaled();
                const existing_sets = new Set(tris.map(t => t.points.slice().sort((a, b) => a - b).join(',')));
                const new_tris_raw = all_tris.filter(t => !existing_sets.has(t.slice().sort((a, b) => a - b).join(',')));
                const new_tris = [];
                for (const t of new_tris_raw) { const tri_pts = [pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos]; const center = tri_center_scaled(tri_pts); new_tris.push({ points: t, center, color: PLAYERS_COLORS[turn] }); }
                if (new_tris.length) { await animateTriangleCentersScaled(new_tris); for (const nt of new_tris) { tris.push({ points: nt.points, owner: turn }); score[turn]++; } }
                moves[turn]--; if (!end_if_needed_scaled()) next_turn_local_scaled();
              }
            }
          }
          sel = null; drag_pos = null; drawImmediate();
        }
      }
    }

    function handlePointerMove(clientX, clientY) {
      const pos = canvasPosFromEvent(clientX, clientY);
      const mx = pos.x, my = pos.y;
      if (sel !== null && !animating && !waiting_for_server) { drag_pos = [mx, my]; drawImmediate(); }
    }

    canvas.addEventListener('mousedown', (ev) => { handlePointerDown(ev.clientX, ev.clientY); });
    canvas.addEventListener('mousemove', (ev) => { handlePointerMove(ev.clientX, ev.clientY); });

    canvas.addEventListener('touchstart', (ev) => {
      ev.preventDefault();
      const t = ev.touches[0];
      if (!t) return;
      handlePointerDown(t.clientX, t.clientY);
    });
    canvas.addEventListener('touchmove', (ev) => {
      ev.preventDefault();
      const t = ev.touches[0];
      if (!t) return;
      handlePointerMove(t.clientX, t.clientY);
    });
    canvas.addEventListener('touchend', (ev) => {
      // clear selection on touch end to avoid stuck selection
      if (sel !== null) { sel = null; drag_pos = null; drawImmediate(); }
    });

    window.addEventListener('keydown', (ev) => {
      if (room_chosen === null && con.length === 0 && tris.length === 0 && input_active) {
        if (ev.key === 'Backspace') {
          if (input_active === 'name') input_name = input_name.slice(0, -1);
          else input_room = input_room.slice(0, -1);
        } else if (ev.key === 'Enter') input_active = null;
        else if (ev.key.length === 1) {
          if (input_active === 'name') input_name += ev.key;
          else input_room += ev.key;
        }
        drawImmediate();
      }
    });

    function drawLobbyUI() {
      ctx.fillStyle = '#1e1e24'; ctx.fillRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      ctx.font = `${Math.max(18, Math.round(36 * scale))}px Arial`; ctx.fillStyle = '#fff';
      const title = 'Lobby';
      const titleW = ctx.measureText(title).width;
      ctx.fillText(title, (canvas.clientWidth - titleW) / 2, sy(20));

      const nameBox = sRect(50, 120, 300, 40);
      roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, true, '#32323c');
      ctx.lineWidth = Math.max(1, Math.round(2 * scale)); ctx.strokeStyle = '#c8c8c8'; roundRectLocal(ctx, nameBox.x, nameBox.y, nameBox.w, nameBox.h, 6, false);
      ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Name: ' + input_name, nameBox.x + sx(10), nameBox.y + sy(8));

      const roomBox = sRect(50, 180, 300, 40);
      roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, true, '#32323c'); roundRectLocal(ctx, roomBox.x, roomBox.y, roomBox.w, roomBox.h, 6, false);
      ctx.fillStyle = '#fff'; ctx.fillText('Room: ' + input_room, roomBox.x + sx(10), roomBox.y + sy(8));

      const counts = [2, 3, 4];
      for (let i = 0; i < counts.length; i++) {
        const x = sx(520) + i * Math.round((66 + 6) * scale);
        const y = sy(120);
        const wRect = Math.round(66 * scale), hRect = Math.round(36 * scale);
        roundRectLocal(ctx, x, y, wRect, hRect, 6, true, (counts[i] === selectedPlayerCount) ? '#3cc078' : '#444');
        ctx.fillStyle = (counts[i] === selectedPlayerCount) ? '#000' : '#fff';
        ctx.font = FONT;
        ctx.fillText(String(counts[i]), x + wRect / 2 - ctx.measureText(String(counts[i])).width / 2, y + Math.round(6 * scale));
      }

      const createBtn = sRect(380, 120, 140, 40);
      const joinBtn = sRect(380, 180, 140, 40);
      roundRectLocal(ctx, createBtn.x, createBtn.y, createBtn.w, createBtn.h, 6, true, '#4682b4');
      roundRectLocal(ctx, joinBtn.x, joinBtn.y, joinBtn.w, joinBtn.h, 6, true, '#4682b4');
      ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Create', createBtn.x + sx(25), createBtn.y + sy(8)); ctx.fillText('Join', joinBtn.x + sx(35), joinBtn.y + sy(8));

      ctx.fillStyle = '#fff'; ctx.fillText('Players in room:', sx(50), sy(250));
      let y = sy(290);
      ctx.font = FONT;
      for (const p of lobby_players) { const flag = p.isHost ? ' (host)' : ''; ctx.fillStyle = '#e6e6e6'; ctx.fillText(`${p.index + 1}. ${p.name}${flag}`, sx(60), y); y += sy(30); }

      if (is_host && room_chosen) { roundRectLocal(ctx, sx(800), sy(120), sx(140), sy(40), 6, true, '#3cc078'); ctx.fillStyle = '#000'; ctx.fillText('Start', sx(830), sy(128)); }

      ctx.fillStyle = '#fff'; ctx.fillText('Servers:', sx(520), sy(220));
      serversButtonRects = [];
      let syPos = sy(260);
      ctx.font = `${Math.max(10, Math.round(14 * scale))}px Arial`;
      for (let i = 0; i < servers.length; i++) {
        const sRow = servers[i];
        const rx = sx(520), rw = Math.round(440 * scale), rh = Math.round(40 * scale);
        roundRectLocal(ctx, rx, syPos, rw, rh, 6, true, '#2a2a33');
        ctx.fillStyle = '#fff';
        const label = `${sRow.id} ‚Äî players: ${sRow.players}/${sRow.maxPlayers} ${sRow.started ? '[started]' : ''}`;
        ctx.fillText(label, rx + sx(10), syPos + Math.round(10 * scale));
        const bx = rx + rw - Math.round(80 * scale), by = syPos + Math.round(6 * scale), bw = Math.round(70 * scale), bh = Math.round(28 * scale);
        roundRectLocal(ctx, bx, by, bw, bh, 6, true, '#4682b4');
        ctx.fillStyle = '#fff'; ctx.font = FONT; ctx.fillText('Join', bx + Math.round(18 * scale), by + Math.round(4 * scale));
        serversButtonRects.push({ x: bx, y: by, w: bw, h: bh });
        syPos += Math.round(54 * scale);
        if (syPos > canvas.clientHeight - Math.round(80 * scale)) break;
      }

      // draw keyboard if editing
      if (input_active) drawKeyboard();

      ctx.font = FONT;
    }

    async function mainLoop() {
      try { await handle_server_messages(); } catch (e) { }
      if (room_chosen === null && con.length === 0 && tris.length === 0) {
        drawLobbyUI();
      } else {
        drawFrame(sel, drag_pos);
        // –û–≤–µ—Ä–ª–µ–π –ø–æ–±–µ–¥–∏—Ç–µ–ª—è (—Å emoji –∏ –∏–º–µ–Ω–µ–º) —Ç–µ–ø–µ—Ä—å —Ä–∏—Å—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –≤ drawFrame()
      }
      requestAnimationFrame(mainLoop);
    }
    requestAnimationFrame(mainLoop);

    (async () => { try { await ws_client.connect(); requestRoomsList(); } catch (e) { console.warn('initial ws connect failed', e); } })();
    setInterval(() => { if (ws_client.connected && room_chosen === null) requestRoomsList(); }, 5000);

    function logState() { console.log({ con, tris, score, moves, turn, room_chosen, player_index, servers, playerNames }); }

  </script>
</body>

</html>
