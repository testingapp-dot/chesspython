<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="manifest" href="manifest.json">
    <title>Triggle - Chess Game</title>
    <style>
        :root {
            --bg1: #0b1220;
            --bg2: #020617;
            --panel: #0f1721cc;
            --glass: rgba(255, 255, 255, 0.04);
            --accent: #3cc078;
            --accent2: #2a8bd6;
            --muted: #cfd8e3aa;
            --radius: 18px;
            --pad: 16px;
            --glass-border: rgba(255, 255, 255, 0.06);
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: Inter, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background:
                radial-gradient(1200px 600px at 10% 10%, rgba(58, 64, 96, 0.25), transparent 55%),
                linear-gradient(180deg, var(--bg1), var(--bg2));
            color: #eef2ff;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            touch-action: none;
        }

        /* ===================== MAIN MENU ===================== */

        .main-menu {
            max-width: 420px;
            margin: 0 auto;
            padding: 18px 20px 32px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
            min-height: 100vh;
        }

        .top-bar {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .profile-pill,
        .howto-pill {
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.45);
            background: linear-gradient(145deg, rgba(18, 27, 48, 0.95), rgba(30, 46, 90, 0.98));
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .profile-pill {
            flex: 1;
            padding: 4px 10px;
            gap: 8px;
            background: linear-gradient(145deg, #101728, #17233e);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            transition: background 180ms ease-out;
            min-height: 42px;
            overflow: hidden;
        }

        .profile-main {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }

        .profile-avatar {
            width: 34px;
            height: 34px;
            border-radius: 12px;
            background: radial-gradient(circle at 30% 20%, #ffe2b5, #f7a15d);
            position: relative;
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.5);
            flex-shrink: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .profile-avatar::after {
            content: '';
            position: absolute;
            inset: 7px;
            border-radius: 999px 999px 60% 60%;
            border-bottom: 3px solid rgba(0, 0, 0, 0.18);
        }

        .profile-meta {
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 2px;
        }

        .profile-name {
            font-size: 13px;
            font-weight: 700;
        }

        .profile-extra {
            display: none;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: space-between;
        }

        .profile-pill.open .profile-main {
            display: none;
        }

        .profile-pill.open .profile-extra {
            display: flex;
        }

        .upload-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: linear-gradient(135deg, #1f2937, #020617);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .upload-btn span {
            margin-left: 6px;
        }

        .avatar-error {
            font-size: 11px;
            color: #ff7b7b;
            min-height: 14px;
        }

        .howto-pill {
            padding: 8px 14px;
            font-size: 13px;
            font-weight: 700;
            background: linear-gradient(145deg, #3b2b7a, #5b35b0);
            cursor: pointer;
        }

        .logo {
            margin-top: 4px;
            text-align: center;
        }

        .logo-main {
            font-size: 32px;
            font-weight: 900;
            letter-spacing: 0.16em;
        }

        .logo-main span {
            color: #ffd75e;
        }

        .logo-main .boomerang {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 18px 18px 4px 4px;
            margin: 0 4px;
            background:
                radial-gradient(circle at 30% 10%, #ffffff, #9be4ff 50%, #00b8ff 75%, #0171ff 100%);
            transform: rotate(45deg) translateY(3px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.55);
        }

        .modes {
            margin-top: 6px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .mode-card {
            position: relative;
            border-radius: 22px;
            padding: 0 14px 14px;
            overflow: hidden;
            box-shadow: 0 18px 36px rgba(0, 0, 0, 0.55);
        }

        .mode-header {
            height: 26px;
            margin: 0 -14px 6px;
            padding: 0 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .mode-body {
            padding: 8px 6px 12px;
            text-align: center;
        }

        .mode-title {
            font-size: 22px;
            font-weight: 900;
            letter-spacing: 0.1em;
            margin-bottom: 4px;
        }

        .mode-sub {
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.18em;
        }

        .mode-footer {
            margin-top: 10px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 14px;
            font-size: 11px;
            font-weight: 700;
        }

        .mode-footer span {
            padding-top: 4px;
        }

        .mode-pill {
            padding: 2px 10px 3px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
        }

        .mode-play {
            background: radial-gradient(circle at 12% 0%, #54b6ff 0, #0055ff 50%, #061631 100%);
            cursor: pointer;
        }

        .mode-play .mode-header {
            background: linear-gradient(90deg, #31d36c, #66ffba);
            color: #053820;
        }

        .mode-play .mode-title {
            color: #ffffff;
        }

        .mode-play .mode-sub {
            color: rgba(199, 226, 255, 0.9);
        }

        .mode-play:hover {
            transform: translateY(-3px);
            transition: transform 160ms ease-out;
        }

        .mode-pass {
            background: radial-gradient(circle at 10% 0%, #ffb267 0, #ff583c 45%, #31101a 100%);
            cursor: pointer;
        }

        .mode-pass .mode-header {
            background: linear-gradient(90deg, #ff9655, #ffce63);
            color: #451106;
        }

        .mode-pass .mode-title {
            color: #ffe7df;
        }

        .mode-pass .mode-sub {
            color: #fbd3c3;
        }

        .mode-pass .mode-footer .mode-pill {
            background: rgba(0, 0, 0, 0.26);
        }

        .mode-single {
            background: radial-gradient(circle at 10% 0%, #8effb2 0, #20b56a 40%, #051b14 100%);
            cursor: pointer;
        }

        .mode-single .mode-header {
            background: linear-gradient(90deg, #74ffb0, #b4ffde);
            color: #074224;
        }

        .mode-single .mode-title {
            color: #e6fff1;
        }

        .mode-single .mode-sub {
            color: #c7ffe1;
        }

        .mode-single .mode-footer .mode-pill {
            background: rgba(0, 0, 0, 0.18);
        }

        .tiny-avatars {
            margin-top: 8px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .tiny-avatar {
            width: 32px;
            height: 32px;
            border-radius: 999px;
            background: radial-gradient(circle at 30% 15%, #ffe7bf, #f59f71 40%, #b04d28 85%);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5);
        }

        .tiny-avatar.bot {
            background: radial-gradient(circle at 30% 10%, #d7f2ff, #95d0ff 45%, #356faa 80%);
        }

        .tiny-avatar.silhouette {
            background: radial-gradient(circle at 30% 10%, #78c4ff, #257bdb 65%, #0450a8 92%);
        }

        /* ===================== LOBBY ===================== */

        .wrap {
            width: 100%;
            max-width: 980px;
            margin: 24px auto 40px;
            padding: 20px;
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }

        #lobbyWrap {
            display: none;
        }

        .left {
            width: 420px;
            min-width: 320px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .card {
            border-radius: var(--radius);
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            padding: 14px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 12px 30px rgba(2, 6, 23, 0.55);
        }

        .card h2 {
            margin: 0 0 8px 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card .muted {
            color: var(--muted);
            font-size: 13px
        }

        .row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .inputs {
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1;
        }

        .field {
            background: var(--glass);
            border-radius: 12px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, 0.04);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .field input {
            border: 0;
            background: transparent;
            color: inherit;
            font-size: 15px;
            outline: none;
            width: 100%;
        }

        .small-btn {
            padding: 10px 12px;
            border-radius: 10px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            border: 1px solid rgba(255, 255, 255, 0.04);
            cursor: pointer;
            color: inherit;
            font-weight: 600;
        }

        .pc-select {
            display: flex;
            gap: 8px;
        }

        .pc-select button {
            min-width: 54px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 0;
            background: #22252b;
            color: #dfe7f6;
            font-weight: 700;
            cursor: pointer;
            box-shadow: inset 0 -6px 16px rgba(0, 0, 0, 0.35);
        }

        .pc-select button.active {
            background: linear-gradient(90deg, var(--accent), #68d09a);
            color: #02120a;
            box-shadow: 0 8px 30px rgba(60, 192, 120, 0.4);
            transform: translateY(-2px);
        }

        .primary {
            background: linear-gradient(90deg, #6bb3ff, #6aa9ff);
            color: #031023;
            border-radius: 12px;
            padding: 12px 18px;
            font-weight: 800;
            border: 0;
            cursor: pointer;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 12px 30px rgba(42, 139, 214, 0.4);
        }

        .secondary {
            background: linear-gradient(90deg, #2a2f37, #2d3138);
            color: #fff;
            border-radius: 12px;
            padding: 12px 18px;
            font-weight: 700;
            border: 0;
            cursor: pointer;
        }

        .right {
            width: 340px;
            min-width: 280px;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }

        .players-list,
        .servers-list {
            padding: 12px;
            border-radius: 16px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
            border: 1px solid var(--glass-border);
            box-shadow: 0 10px 28px rgba(0, 0, 0, 0.55);
        }

        .players-list h3,
        .servers-list h3 {
            margin: 0 0 10px 0;
            font-size: 15px;
        }

        .player-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 10px;
            margin-bottom: 8px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
        }

        .avatar {
            width: 42px;
            height: 42px;
            border-radius: 10px;
            background: linear-gradient(135deg, #ffd88a, #f07b65);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            color: #04110d;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }

        .player-meta {
            flex: 1;
        }

        .player-meta b {
            display: block
        }

        .player-actions {
            display: flex;
            gap: 8px;
        }

        .server-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px;
            border-radius: 10px;
            margin-bottom: 10px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), transparent);
        }

        .join-server {
            padding: 8px 12px;
            border-radius: 8px;
            background: linear-gradient(90deg, var(--accent2), #6aa9ff);
            border: 0;
            color: #021225;
            font-weight: 800;
            cursor: pointer;
        }

        .vkb {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 80;
            transform: translateY(100%);
            transition: transform 240ms cubic-bezier(.22, .9, .25, 1);
            padding: 12px;
            background: linear-gradient(180deg, rgba(6, 10, 18, 0.96), rgba(10, 14, 22, 0.98));
            box-shadow: 0 -18px 48px rgba(3, 6, 12, 0.6);
            border-top-left-radius: 18px;
            border-top-right-radius: 18px;
            border: 1px solid rgba(255, 255, 255, 0.03);
        }

        .vkb.show {
            transform: translateY(0%);
        }

        .vkb .row {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .key {
            flex: 1;
            padding: 12px 8px;
            border-radius: 10px;
            background: #1e2329;
            border: 1px solid rgba(255, 255, 255, 0.03);
            text-align: center;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
        }

        .key.wide {
            flex: 2;
        }

        .key.space {
            flex: 3;
        }

        .key.alt {
            background: #2c2f36;
            color: #fff;
        }

        .kbd-ctrl {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        /* ===================== GAME SCREEN ===================== */

        #gameScreen {
            display: none;
            min-height: 100vh;
            padding: 16px 12px 20px;
            max-width: 900px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .game-header {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-bottom: 4px;
        }

        .game-top-bar {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .game-player-card {
            flex: 1;
            min-width: 0;
            padding: 8px 10px;
            border-radius: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, #020617, #020617);
            border: 1px solid rgba(148, 163, 184, 0.5);
            box-shadow: 0 12px 28px rgba(0, 0, 0, 0.7);
            font-size: 12px;
            font-weight: 700;
        }

        .game-player-card .avatar-circle {
            width: 32px;
            height: 32px;
            border-radius: 999px;
            background: radial-gradient(circle at 30% 10%, #fff7dc, #ffd18b 40%, #e88a44 80%);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.45);
        }

        .game-player-meta {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .game-player-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .game-player-label {
            font-size: 15px;
            color: var(--muted);
        }

        .game-player-card.me {
            align-self: flex-end;
            padding: 10px 14px;
            font-size: 14px;
            background: linear-gradient(135deg, #0f172a, #1d3655);
            border-color: rgba(148, 163, 184, 0.5);
            /* –±–µ–∑ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –ø–æ–¥—Å–≤–µ—Ç–∫–∏ */
            /* <<< */
        }

        /* –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Ç–æ–≥–æ –∏–≥—Ä–æ–∫–∞, —á–µ–π —Ö–æ–¥ */
        /* <<< */
        .game-player-card.turn {
            border-color: rgba(96, 165, 250, 0.9);
            box-shadow: 0 12px 28px rgba(37, 99, 235, 0.6);
        }

        .badge-pill {
            padding: 2px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 700;
            background: rgba(15, 23, 42, 0.95);
        }

        .game-board-wrap {
            flex: 0 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 0 12px;
        }

        /* –≤—ã—Å–æ–∫–∏–π –∫–∞–Ω–≤–∞—Å, —á—Ç–æ–±—ã –≤–µ—Ä—Ö/–Ω–∏–∑ –≥–µ–∫—Å–∞ –Ω–µ —Å—Ä–µ–∑–∞–ª–∏—Å—å */
        #gameCanvas {
            width: min(100vw - 24px, 900px);
            height: calc(min(100vw - 24px, 900px) * 1.15);
            max-width: 900px;
            border-radius: 24px;
            background:
                radial-gradient(circle at 20% 15%, rgba(148, 163, 184, 0.18), transparent 50%),
                radial-gradient(circle at 80% 85%, rgba(59, 130, 246, 0.25), transparent 60%),
                #020617;
            box-shadow:
                0 30px 60px rgba(0, 0, 0, 0.95),
                0 0 0 4px rgba(15, 23, 42, 0.95);
            display: block;
        }

        .game-bottom-bar {
            margin-top: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        #gameBottomPlayer {
            width: 100%;
            max-width: 360px;
        }

        /* ====== winner overlay ====== */
        #winnerOverlay {
            position: fixed;
            inset: 0;
            z-index: 200;
            display: none;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at 20% 0, rgba(59, 130, 246, 0.35), transparent 55%),
                radial-gradient(circle at 80% 100%, rgba(34, 197, 94, 0.35), transparent 55%),
                rgba(15, 23, 42, 0.96);
            color: #e5e7eb;
        }

        #winnerOverlay .card {
            border-radius: 24px;
            padding: 22px 26px 20px;
            max-width: 360px;
            width: 90%;
            text-align: center;
            background: radial-gradient(circle at 0 0, rgba(250, 250, 250, 0.1), transparent 55%),
                linear-gradient(145deg, #020617, #020617);
            border: 1px solid rgba(148, 163, 184, 0.5);
            box-shadow: 0 24px 60px rgba(0, 0, 0, 0.8);
        }

        #winnerOverlay .winner-avatar {
            width: 70px;
            height: 70px;
            border-radius: 999px;
            margin: 0 auto 10px;
            background: radial-gradient(circle at 30% 10%, #fff7dc, #ffd18b 40%, #e88a44 80%);
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.6);
            background-size: cover;
            background-position: center;
            overflow: hidden;
            border: 2px solid rgba(250, 250, 250, 0.9);
        }

        #winnerOverlay .emoji {
            font-size: 40px;
            margin-bottom: 6px;
        }

        #winnerOverlay h2 {
            margin: 4px 0 6px;
            font-size: 22px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        #winnerOverlay p {
            margin: 4px 0;
            font-size: 14px;
            color: #cbd5f5;
        }

        #winnerCountdown {
            font-size: 13px;
            margin-top: 8px;
            color: #e5e7eb;
            opacity: 0.9;
        }

        #winnerOverlay .btn {
            margin-top: 14px;
            padding: 10px 16px;
            border-radius: 999px;
            border: 0;
            cursor: pointer;
            font-weight: 700;
            font-size: 13px;
            background: linear-gradient(90deg, #22c55e, #4ade80);
            color: #022c16;
            box-shadow: 0 10px 26px rgba(34, 197, 94, 0.5);
        }

        .alert-bar {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            padding: 10px 18px;
            border-radius: 999px;
            background: rgba(15, 23, 42, 0.96);
            border: 1px solid rgba(248, 250, 252, 0.4);
            color: #e5e7eb;
            font-size: 13px;
            font-weight: 700;
            box-shadow: 0 14px 30px rgba(0, 0, 0, 0.6);
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
        }

        /* –≤–∏–¥–∏–º–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ */
        .alert-bar.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* –¢–∏–ø—ã —Å–æ–æ–±—â–µ–Ω–∏–π (–ø–æ –∂–µ–ª–∞–Ω–∏—é) */
        .alert-bar.info {
            border-color: rgba(96, 165, 250, 0.9);
        }

        .alert-bar.error {
            border-color: rgba(248, 113, 113, 0.95);
        }

        .alert-bar.success {
            border-color: rgba(74, 222, 128, 0.95);
        }


        @media (max-width:920px) {
            .wrap {
                padding: 12px;
                gap: 12px;
                flex-direction: column;
                align-items: stretch
            }

            .left,
            .right {
                width: 100%
            }

            #gameCanvas {
                width: calc(100vw - 24px);
                height: calc((100vw - 24px) * 1.15);
            }
        }
    </style>
</head>

<body>
    <div id="alertBar" class="alert-bar"></div>

    <!-- ===================== MAIN MENU ===================== -->
    <div id="mainMenu" class="main-menu">
        <div class="top-bar">
            <div class="profile-pill" id="profilePill">
                <div class="profile-main">
                    <div class="profile-avatar" id="profileAvatar"></div>
                    <div class="profile-meta">
                        <div class="profile-name">Player</div>
                    </div>
                </div>
                <div class="profile-extra">
                    <label class="upload-btn" id="uploadAvatarLabel">
                        <svg width="14" height="14" viewBox="0 0 24 24">
                            <path fill="currentColor" d="M5 20h14v-2H5v2zm7-16l-5 5h3v4h4v-4h3l-5-5z" />
                        </svg>
                        <span>Upload avatar</span>
                        <input type="file" id="avatarInput" accept="image/*" hidden>
                    </label>
                    <div class="avatar-error" id="avatarError"></div>
                </div>
            </div>

            <!-- –ö–Ω–æ–ø–∫–∞ How to play —É–±—Ä–∞–Ω–∞ --> <!-- <<< -->
        </div>

        <div class="logo">
            <div class="logo-main">
                TRIGGLE
            </div>
        </div>

        <div class="modes">
            <div id="playPanel" class="mode-card mode-play">
                <div class="mode-header">MULTIPLAYER</div>
                <div class="mode-body">
                    <div class="mode-title">PLAY</div>
                    <div class="mode-sub">ONLINE MULTIPLAYER</div>

                    <div class="tiny-avatars">
                        <div class="tiny-avatar"></div>
                        <div class="tiny-avatar silhouette"></div>
                        <div class="tiny-avatar silhouette"></div>
                        <div class="tiny-avatar silhouette"></div>
                    </div>

                    <div class="mode-footer">
                        <span>YOU</span>
                        <span>VS</span>
                        <span>?</span>
                        <span>VS</span>
                        <span>?</span>
                    </div>
                </div>
            </div>

            <div class="mode-card mode-single" id="singlePanel">
                <div class="mode-header">Single Player</div>
                <div class="mode-body">
                    <div class="mode-title">SINGLE</div>
                    <div class="mode-sub">PLAYER</div>

                    <div class="tiny-avatars">
                        <div class="tiny-avatar"></div>
                        <div class="tiny-avatar bot"></div>
                    </div>

                    <div class="mode-footer">
                        <span class="mode-pill">YOU</span>
                        <span>VS</span>
                        <span class="mode-pill">BOT</span>
                    </div>
                </div>
            </div>

            <!-- Subscription –±–ª–æ–∫ —É–±—Ä–∞–Ω --> <!-- <<< -->
        </div>
    </div>

    <!-- ===================== LOBBY ===================== -->
    <div id="lobbyWrap" class="wrap">
        <div class="left">
            <button id="backBtn" class="small-btn" style="align-self:flex-start;margin-bottom:4px;">‚Üê –ù–∞–∑–∞–¥</button>

            <div class="card" id="lobby-card">
                <h2>
                    <svg width="18" height="18" viewBox="0 0 24 24" style="opacity:.9">
                        <path fill="currentColor" d="M12 2L2 7v7c0 5 4 9 10 9s10-4 10-9V7l-10-5z" />
                    </svg>
                    Create Server
                </h2>

                <div class="row">
                    <div class="inputs">
                        <div class="field">
                            <svg width="18" height="18" viewBox="0 0 24 24">
                                <path fill="currentColor"
                                    d="M12 12a5 5 0 100-10 5 5 0 000 10zm0 2c-4.4 0-8 2.2-8 4.9V22h16v-3.1c0-2.7-3.6-4.9-8-4.9z" />
                            </svg>
                            <input id="nameInput" type="text" placeholder="Your name" value="Player" />
                        </div>
                        <div class="field">
                            <svg width="18" height="18" viewBox="0 0 24 24">
                                <path fill="currentColor" d="M12 2l10 6v8l-10 6L2 16V8z" />
                            </svg>
                            <input id="roomInput" type="text" placeholder="Room name" value="room1" />
                        </div>
                    </div>

                    <div style="display:flex;flex-direction:column;gap:8px">
                        <button id="createBtn" class="primary" title="Create room">
                            <svg width="18" height="18" viewBox="0 0 24 24">
                                <path fill="currentColor" d="M12 7v10M7 12h10" stroke="currentColor" stroke-width="0" />
                            </svg>
                            Create
                        </button>
                        <button id="startBtn" class="secondary" style="margin-top:6px">Start</button>
                    </div>
                </div>

                <div style="margin-top:12px;display:flex;align-items:center;justify-content:space-between;gap:12px">
                    <div>
                        <div class="muted" style="font-size:13px;margin-bottom:8px">Players</div>
                        <div class="pc-select" role="tablist" aria-label="player-count">
                            <button data-count="2" class="pc-btn">2</button>
                            <button data-count="3" class="pc-btn">3</button>
                            <button data-count="4" class="pc-btn active">4</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="right">
            <div class="players-list card">
                <h3>Players in room</h3>
                <div id="playersContainer"></div>
                <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
                    <button id="leaveBtn" class="small-btn">Leave</button>
                    <div style="flex:1"></div>
                    <div class="muted">Max: <b id="maxPlayersLabel">4</b></div>
                </div>
            </div>

            <div class="servers-list card">
                <h3>Servers</h3>
                <div id="serversContainer"></div>
                <div style="display:flex;justify-content:center;margin-top:8px">
                    <button id="refreshServers" class="small-btn">Refresh</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ===================== GAME SCREEN ===================== -->
    <div id="gameScreen">
        <div class="game-header">
            <button id="gameExitBtn" class="small-btn">‚Üê –í—ã–π—Ç–∏</button>
        </div>

        <div class="game-top-bar" id="gameTopPlayers"></div>

        <div class="game-board-wrap">
            <canvas id="gameCanvas"></canvas>
        </div>

        <div class="game-bottom-bar">
            <div id="gameBottomPlayer"></div>
            <button id="endTurnBtn" class="secondary" style="max-height:42px;white-space:nowrap;">
                End turn
            </button>
        </div>
    </div>

    <!-- WINNER OVERLAY -->
    <div id="winnerOverlay">
        <div class="card">
            <div class="winner-avatar" id="winnerAvatar"></div>
            <div class="emoji" id="winnerEmoji">üèÜ</div>
            <h2 id="winnerTitle">WINNER</h2>
            <p id="winnerNameLabel">Player 1</p>
            <p id="winnerSubtitle">Nice triggles!</p>
            <div id="winnerCountdown">Returning to main menu in 10‚Ä¶</div>
            <button class="btn" id="winnerSkipBtn">Back to main menu now</button>
        </div>
    </div>

    <!-- virtual keyboard -->
    <div id="vkb" class="vkb" aria-hidden="true">
        <div class="row" id="row1"></div>
        <div class="row" id="row2"></div>
        <div class="row" id="row3"></div>
        <div class="row" id="row4"></div>
        <div class="kbd-ctrl">
            <div class="key alt" data-key="BACK">BACK</div>
            <div class="key space" data-key=" ">SPACE</div>
            <div class="key alt" data-key="ENTER">ENTER</div>
        </div>
    </div>

    <script>
        const WS_URL = 'wss://frosty-colden.185-234-114-50.plesk.page';

        const mainMenu = document.getElementById('mainMenu');
        const alertBar = document.getElementById('alertBar');
        const lobbyWrap = document.getElementById('lobbyWrap');
        const gameScreen = document.getElementById('gameScreen');
        const playPanel = document.getElementById('playPanel');
        const singlePanel = document.getElementById('singlePanel');

        let alertBarTimer = null;

        function showAlertBar(message, type = 'info', duration = 2500) {
            if (!alertBar) return;
            // —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–ª–∞—Å—Å—ã
            alertBar.className = 'alert-bar';
            if (type) alertBar.classList.add(type);
            alertBar.textContent = message;

            // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º
            alertBar.classList.add('show');

            if (alertBarTimer) clearTimeout(alertBarTimer);
            alertBarTimer = setTimeout(() => {
                alertBar.classList.remove('show');
            }, duration);
        }

        playPanel.addEventListener('click', () => {
            mainMenu.style.display = 'none';
            lobbyWrap.style.display = 'flex';
            gameScreen.style.display = 'none';
            connectWS();
            requestRoomsList();
            startRoomsAutoRefresh();
            window.scrollTo(0, 0);
        });

        const backBtn = document.getElementById('backBtn');
        backBtn.addEventListener('click', () => {
            lobbyWrap.style.display = 'none';
            gameScreen.style.display = 'none';
            mainMenu.style.display = 'flex';
            stopRoomsAutoRefresh();
            window.scrollTo(0, 0);
        });

        singlePanel.addEventListener('click', () => {
            startSinglePlayerGame();
        });

        // Lobby elements
        const nameInput = document.getElementById('nameInput');
        const roomInput = document.getElementById('roomInput');
        const createBtn = document.getElementById('createBtn');
        const startBtn = document.getElementById('startBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const refreshServers = document.getElementById('refreshServers');
        const playersContainer = document.getElementById('playersContainer');
        const serversContainer = document.getElementById('serversContainer');
        const maxPlayersLabel = document.getElementById('maxPlayersLabel');
        const profileNameEl = document.querySelector('.profile-name');

        /* ===== IndexedDB for name & avatar ===== */
        let dbPromise = null;
        function getDB() {
            if (dbPromise) return dbPromise;
            dbPromise = new Promise((resolve, reject) => {
                const request = indexedDB.open('triangoDB', 1);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('settings')) {
                        db.createObjectStore('settings', { keyPath: 'id' });
                    }
                };
                request.onsuccess = e => resolve(e.target.result);
                request.onerror = e => reject(e.target.error);
            });
            return dbPromise;
        }
        async function saveToSettings(key, value) {
            const db = await getDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('settings', 'readwrite');
                const store = tx.objectStore('settings');
                store.put({ id: key, value });
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
                tx.onabort = () => reject(tx.error);
            });
        }
        async function loadFromSettings(key) {
            const db = await getDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('settings', 'readonly');
                const store = tx.objectStore('settings');
                const req = store.get(key);
                req.onsuccess = () => resolve(req.result ? req.result.value : null);
                req.onerror = () => reject(req.error);
            });
        }

        function hasValidName() { return nameInput.value.trim().length > 0; }
        function updateProfileNameView() {
            const value = nameInput.value;
            profileNameEl.textContent = value.trim() || 'Player';
        }

        nameInput.addEventListener('input', () => {
            updateProfileNameView();
            saveToSettings('playerName', nameInput.value).catch(console.warn);
        });

        (async function initName() {
            try {
                const saved = await loadFromSettings('playerName');
                if (saved !== null && saved !== undefined) {
                    nameInput.value = saved;
                } else {
                    nameInput.value = 'Player';
                    await saveToSettings('playerName', 'Player');
                }
            } catch (e) {
                nameInput.value = 'Player';
            }
            updateProfileNameView();
        })();

        /* ===== WebSocket client ===== */
        let ws = null;
        let wsConnected = false;
        let roomsRefreshInterval = null;
        let isSinglePlayer = false;

        let currentRoomId = null;
        let currentPlayerIndex = null;
        let isHost = false;
        let hostIndex = null;
        let roomMinPlayers = 2;
        let roomMaxPlayers = 4;

        let lobbyPlayers = [];
        let roomsList = [];

        function connectWS() {
            if (isSinglePlayer) return;
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
            ws = new WebSocket(WS_URL);

            ws.onopen = () => {
                wsConnected = true;
                console.log('WS connected');
            };

            ws.onclose = () => {
                wsConnected = false;
                console.log('WS closed');
            };

            ws.onerror = (e) => {
                console.error('WS error', e);
            };

            ws.onmessage = (event) => {
                let data;
                try { data = JSON.parse(event.data); } catch (e) { console.error('bad json', e); return; }
                console.log('WS msg', data);

                switch (data.type) {
                    case 'created':
                        currentRoomId = data.room;
                        currentPlayerIndex = data.playerIndex;
                        isHost = true;
                        roomMinPlayers = data.minPlayers || 2;
                        roomMaxPlayers = data.maxPlayers || roomMaxPlayers;
                        requestRoomsList();
                        break;

                    case 'joined':
                        currentRoomId = data.room;
                        currentPlayerIndex = data.playerIndex;
                        isHost = false;
                        break;

                    case 'lobby':
                        lobbyPlayers = data.players || [];
                        hostIndex = data.hostIndex;
                        isHost = (currentPlayerIndex === hostIndex);
                        roomMinPlayers = data.minPlayers || roomMinPlayers;
                        roomMaxPlayers = data.maxPlayers || roomMaxPlayers;
                        renderPlayers();
                        break;

                    case 'rooms_list':
                        roomsList = data.rooms || [];
                        renderServers();
                        break;

                    case 'start':
                        handleGameStart(data);
                        break;

                    case 'state_update':
                        handleStateUpdate(data);
                        break;

                    case 'game_over':
                        handleGameOver(data);
                        break;

                    case 'leave_room': {
                        const reason = data.reason || 'server';

                        if (reason !== 'game_over') {
                            showAlertBar('–ò–≥—Ä–æ–∫ –≤—ã—à–µ–ª –∏–∑ –∏–≥—Ä—ã (' + reason + ')', 'info');
                            resetRoomClientState();
                            showMainMenu();
                        } else {
                            resetRoomClientState();
                        }

                        break;
                    }

                    case 'error':
                        showAlertBar('Error: ' + (data.message || 'unknown'), 'error');
                        break;
                }
            };
        }

        function sendWS(obj) {
            const str = JSON.stringify(obj);
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(str);
            } else if (!isSinglePlayer) {
                connectWS();
                ws.addEventListener('open', () => ws.send(str), { once: true });
            }
        }

        function requestRoomsList() {
            if (isSinglePlayer) return;
            if (!wsConnected && (!ws || ws.readyState !== WebSocket.CONNECTING)) connectWS();
            sendWS({ type: 'list_rooms' });
        }

        function startRoomsAutoRefresh() {
            if (isSinglePlayer) return;
            if (roomsRefreshInterval) clearInterval(roomsRefreshInterval);
            roomsRefreshInterval = setInterval(() => {
                if (lobbyWrap.style.display !== 'none') {
                    requestRoomsList();
                }
            }, 10000);
        }

        function stopRoomsAutoRefresh() {
            if (roomsRefreshInterval) {
                clearInterval(roomsRefreshInterval);
                roomsRefreshInterval = null;
            }
        }

        function resetRoomClientState() {
            currentRoomId = null;
            currentPlayerIndex = null;
            lobbyPlayers = [];
            roomsList = [];
            isHost = false;
            hostIndex = null;
            roomMinPlayers = 2;
            roomMaxPlayers = 4;
            renderPlayers();
            renderServers();
            stopRoomsAutoRefresh();
            isSinglePlayer = false;
        }

        function showMainMenu() {
            gameScreen.style.display = 'none';
            lobbyWrap.style.display = 'none';
            mainMenu.style.display = 'flex';
            stopRoomsAutoRefresh();
        }

        /* ===== Lobby rendering ===== */
        function renderPlayers() {
            playersContainer.innerHTML = '';
            if (!lobbyPlayers.length) {
                playersContainer.innerHTML = '<div class="muted">No players in room</div>';
            } else {
                lobbyPlayers.forEach(p => {
                    const row = document.createElement('div');
                    row.className = 'player-row';

                    const avatarDiv = document.createElement('div');
                    avatarDiv.className = 'avatar';
                    if (p.avatar) {
                        avatarDiv.style.backgroundImage = `url(${p.avatar})`;
                        avatarDiv.textContent = '';
                    } else {
                        avatarDiv.textContent = (p.name || '?').charAt(0).toUpperCase();
                    }

                    const meta = document.createElement('div');
                    meta.className = 'player-meta';
                    meta.innerHTML = `
          <b>${p.name}</b>
          <span class="muted">Player ${p.index + 1}${p.isHost ? ' ‚Ä¢ host' : ''}</span>
        `;

                    const actions = document.createElement('div');
                    actions.className = 'player-actions';
                    const btn = document.createElement('button');
                    btn.className = 'small-btn';
                    btn.textContent = 'Msg';
                    btn.onclick = () => console.log('message', p.index);
                    actions.appendChild(btn);

                    row.appendChild(avatarDiv);
                    row.appendChild(meta);
                    row.appendChild(actions);
                    playersContainer.appendChild(row);
                });
            }
            maxPlayersLabel.textContent = roomMaxPlayers || '4';

            const canStart = isHost && lobbyPlayers.length >= roomMinPlayers && lobbyPlayers.length <= roomMaxPlayers;
            startBtn.disabled = !canStart;
            startBtn.style.opacity = canStart ? '1' : '0.5';
            startBtn.style.cursor = canStart ? 'pointer' : 'default';
        }

        function renderServers() {
            serversContainer.innerHTML = '';
            if (!roomsList.length) {
                serversContainer.innerHTML = '<div class="muted">No rooms yet</div>';
                return;
            }
            roomsList.forEach(s => {
                const el = document.createElement('div');
                el.className = 'server-row';
                const full = s.players >= s.maxPlayers;
                el.innerHTML = `
        <div style="flex:1">
          <div style="font-weight:700">${s.id} ${s.started ? '<span style="color:#ffcc66;font-weight:600;margin-left:8px">[started]</span>' : ''}</div>
          <div class="muted">Players: ${s.players}/${s.maxPlayers}</div>
        </div>
        <div style="margin-left:12px">
          <button class="join-server">${(!s.started && !full) ? 'Join' : 'Watch'}</button>
        </div>
      `;
                el.querySelector('.join-server').addEventListener('click', () => {
                    if (!hasValidName()) {
                        showAlertBar('–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º, —á—Ç–æ–±—ã –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –∏–≥—Ä–µ', 'error');
                        nameInput.focus();
                        return;
                    }
                    sendWS({
                        type: 'join',
                        room: s.id,
                        name: nameInput.value.trim() || 'Player',
                        avatar: localAvatarDataUrl || null
                    });
                });
                serversContainer.appendChild(el);
            });
        }

        document.querySelectorAll('.pc-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.pc-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        createBtn.addEventListener('click', () => {
            if (!hasValidName()) {
                showAlertBar('–í–≤–µ–¥–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å –ª–æ–±–±–∏', 'error');
                nameInput.focus();
                return;
            }
            const pcBtn = document.querySelector('.pc-btn.active');
            const playerCount = pcBtn ? parseInt(pcBtn.dataset.count, 10) : 4;
            roomMaxPlayers = playerCount;
            roomMinPlayers = 2;
            const roomId = roomInput.value.trim() || 'room';
            sendWS({
                type: 'create',
                room: roomId,
                name: nameInput.value.trim() || 'Player',
                minPlayers: roomMinPlayers,
                maxPlayers: roomMaxPlayers,
                avatar: localAvatarDataUrl || null
            });
            requestRoomsList();
        });

        startBtn.addEventListener('click', () => {
            if (!currentRoomId) {
                showAlertBar('–í—ã –µ—â—ë –Ω–µ –≤ –∫–æ–º–Ω–∞—Ç–µ', 'error');
                return;
            }
            if (!isHost) {
                showAlertBar('–¢–æ–ª—å–∫–æ —Ö–æ—Å—Ç –º–æ–∂–µ—Ç –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É', 'error');
                return;
            }
            sendWS({ type: 'start', room: currentRoomId });
        });

        leaveBtn.addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }
            resetRoomClientState();
        });

        refreshServers.addEventListener('click', () => {
            requestRoomsList();
        });

        /* ===== Virtual keyboard ===== */
        const vkb = document.getElementById('vkb');
        const rows = ['123456789', 'qwertyuiop', 'asdfghjkl', 'zxcvbnm'];
        function buildKeyboard() {
            document.getElementById('row1').innerHTML = rows[0].split('').map(k => `<div class="key" data-key="${k}">${k}</div>`).join('');
            document.getElementById('row2').innerHTML = rows[1].split('').map(k => `<div class="key" data-key="${k}">${k}</div>`).join('');
            document.getElementById('row3').innerHTML = rows[2].split('').map(k => `<div class="key" data-key="${k}">${k}</div>`).join('');
            document.getElementById('row4').innerHTML = rows[3].split('').map(k => `<div class="key" data-key="${k}">${k}</div>`).join('');
            document.querySelectorAll('.key').forEach(el => {
                el.addEventListener('click', () => {
                    const key = el.dataset.key;
                    handleVirtualKey(key);
                });
            });
        }
        buildKeyboard();

        let activeField = null;
        function showKeyboard(show, field = null) {
            if (show) { vkb.classList.add('show'); activeField = field; vkb.setAttribute('aria-hidden', 'false'); }
            else { vkb.classList.remove('show'); activeField = null; vkb.setAttribute('aria-hidden', 'true'); }
        }

        function handleVirtualKey(key) {
            if (!activeField) return;
            if (key === 'BACK') {
                if (activeField === 'name') {
                    nameInput.value = nameInput.value.slice(0, -1);
                    nameInput.dispatchEvent(new Event('input'));
                } else {
                    roomInput.value = roomInput.value.slice(0, -1);
                }
                return;
            }
            if (key === 'ENTER') { showKeyboard(false, null); return; }
            if (key === ' ') {
                if (activeField === 'name') {
                    nameInput.value += ' ';
                    nameInput.dispatchEvent(new Event('input'));
                } else {
                    roomInput.value += ' ';
                }
                return;
            }
            if (activeField === 'name') {
                if (nameInput.value.length < 20) {
                    nameInput.value += key;
                    nameInput.dispatchEvent(new Event('input'));
                }
            } else {
                if (roomInput.value.length < 20) roomInput.value += key;
            }
        }

        nameInput.addEventListener('focus', () => showKeyboard(true, 'name'));
        roomInput.addEventListener('focus', () => showKeyboard(true, 'room'));

        document.addEventListener('click', e => {
            if (!e.target.closest('.field') && !e.target.closest('.vkb')) {
                showKeyboard(false, null);
                nameInput.blur(); roomInput.blur();
            }
        });

        nameInput.addEventListener('touchstart', e => { e.preventDefault(); nameInput.blur(); showKeyboard(true, 'name'); });
        roomInput.addEventListener('touchstart', e => { e.preventDefault(); roomInput.blur(); showKeyboard(true, 'room'); });

        /* ===== Profile avatar + IndexedDB ===== */
        const profilePill = document.getElementById('profilePill');
        const profileAvatar = document.getElementById('profileAvatar');
        const avatarInput = document.getElementById('avatarInput');
        const avatarError = document.getElementById('avatarError');
        const uploadAvatarLabel = document.getElementById('uploadAvatarLabel');

        let localAvatarDataUrl = null;

        profilePill.addEventListener('click', e => {
            if (e.target === avatarInput) return;
            profilePill.classList.toggle('open');
        });
        uploadAvatarLabel.addEventListener('click', e => e.stopPropagation());

        const MAX_SIZE = 1024 * 1024;
        avatarInput.addEventListener('change', e => {
            const file = e.target.files[0];
            avatarError.textContent = '';
            if (!file) return;
            if (file.size > MAX_SIZE) {
                avatarError.textContent = '–§–∞–π–ª –±–æ–ª—å—à–µ 1 –º–±';
                avatarInput.value = '';
                return;
            }
            const reader = new FileReader();
            reader.onload = async () => {
                const dataUrl = reader.result;
                try {
                    await saveToSettings('avatar', dataUrl);
                    applyAvatar(dataUrl);
                } catch (err) { console.error(err); }
            };
            reader.readAsDataURL(file);
        });

        function applyAvatar(dataUrl) {
            localAvatarDataUrl = dataUrl;
            profileAvatar.style.backgroundImage = `url(${dataUrl})`;
            profileAvatar.style.backgroundSize = 'cover';
            profileAvatar.style.backgroundPosition = 'center';
            profileAvatar.style.backgroundRepeat = 'no-repeat';
        }

        (async () => {
            try {
                const avatarData = await loadFromSettings('avatar');
                if (avatarData) applyAvatar(avatarData);
            } catch (e) { console.error(e); }
        })();

        /* ===== Game UI + Board (canvas) ===== */
        const gameTopPlayers = document.getElementById('gameTopPlayers');
        const gameBottomPlayer = document.getElementById('gameBottomPlayer');
        const gameCanvas = document.getElementById('gameCanvas');
        const endTurnBtn = document.getElementById('endTurnBtn');
        const gameExitBtn = document.getElementById('gameExitBtn');
        const gctx = gameCanvas.getContext('2d', { alpha: false });

        // winner overlay
        const winnerOverlay = document.getElementById('winnerOverlay');
        const winnerEmojiEl = document.getElementById('winnerEmoji');
        const winnerTitleEl = document.getElementById('winnerTitle');
        const winnerNameLabel = document.getElementById('winnerNameLabel');
        const winnerSubtitleEl = document.getElementById('winnerSubtitle');
        const winnerCountdownEl = document.getElementById('winnerCountdown');
        const winnerSkipBtn = document.getElementById('winnerSkipBtn');
        const winnerAvatarEl = document.getElementById('winnerAvatar');

        let winnerCountdownTimer = null;
        let winnerCountdownInterval = null;
        let winnerCountdownValue = 10;

        const LOGICAL_BASE_W = 1000;
        const LOGICAL_BASE_H = 700;
        const BASE_SP = 96;
        const BASE_DR = 14; // –±–∞–∑–æ–≤—ã–π —Ä–∞–¥–∏—É—Å —Ç–æ—á–∫–∏

        const R = 4;
        const STEP_POINTS = 4;
        const DEFAULT_MOVES = 15;

        const BG = '#020617';
        const DOT = '#e5e7eb';
        const LINE_COLOR = '#f97316';
        const PLAYERS_COLORS = ['#8b5cf6', '#f97316', '#22c55e', '#38bdf8'];

        let gWIDTH = 0, gHEIGHT = 0, gScale = 1;
        let SP = BASE_SP;
        let DR = BASE_DR;
        let LINE_THICKNESS = 3;

        const pts = [];
        const idx = {};

        let con = [];
        let tris = [];
        let edgeOwner = new Map(); // –≤–ª–∞–¥–µ–ª–µ—Ü –∫–∞–∂–¥–æ–≥–æ —Ä–µ–±—Ä–∞ /* <<< */

        let sel = null;
        let drag_pos = null;

        let turn = 0;
        let moves = [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES]; // —É–∂–µ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º, –Ω–æ –æ—Å—Ç–∞–≤–∏–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        let score = [0, 0, 0, 0];
        let game_over = false;
        let winner = null;

        let playerNames = [];
        let playerAvatars = [];

        let claimMode = false;
        let claimCandidates = [];
        let claimRects = [];

        let animating = false;
        let waiting_for_server = false;
        let tri_delay = 220;
        let gameStarted = false;

        let pointerIsDown = false;

        function setupCanvasSize() {
            const DPR = window.devicePixelRatio || 1;
            const rect = gameCanvas.getBoundingClientRect();
            const cssW = rect.width || window.innerWidth;
            const cssH = rect.height || (window.innerHeight * 0.8);

            gameCanvas.style.width = cssW + 'px';
            gameCanvas.style.height = cssH + 'px';
            gameCanvas.width = Math.round(cssW * DPR);
            gameCanvas.height = Math.round(cssH * DPR);

            gWIDTH = cssW;
            gHEIGHT = cssH;
            gScale = Math.min(gWIDTH / LOGICAL_BASE_W, gHEIGHT / LOGICAL_BASE_H);

            gctx.setTransform(DPR, 0, 0, DPR, 0, 0);

            SP = Math.max(26, Math.round(BASE_SP * gScale));
            DR = Math.max(8, Math.round(BASE_DR * gScale));
            LINE_THICKNESS = Math.max(3, Math.round(5 * gScale));

            buildGrid();
            drawImmediate();
        }

        function buildGrid() {
            pts.length = 0;
            for (let q = -R + 1; q < R; q++) {
                const r1 = Math.max(-R + 1, -q - R + 1);
                const r2 = Math.min(R - 1, -q + R - 1);
                for (let rr = r1; rr <= r2; rr++) {
                    const pos = toxy(q, rr);
                    idx[`${q},${rr}`] = pts.length;
                    pts.push({ pos, q, r: rr });
                }
            }
        }

        function toxy(q, r) {
            const x = SP * (1.5 * q);
            const y = SP * (Math.sqrt(3) * (r + q / 2));
            const cssW = gameCanvas.clientWidth || gWIDTH;
            const cssH = gameCanvas.clientHeight || gHEIGHT;
            return [
                Math.round(x + cssW / 2),
                Math.round(y + cssH / 2)
            ];
        }

        function drawHexagonLocal(color, center, radius, fill = true, width = 0) {
            gctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const ang = (Math.PI / 180) * (60 * i - 30);
                const x = center[0] + radius * Math.cos(ang);
                const y = center[1] + radius * Math.sin(ang);
                if (i === 0) gctx.moveTo(x, y); else gctx.lineTo(x, y);
            }
            gctx.closePath();
            if (fill) {
                gctx.fillStyle = color;
                gctx.fill();
            }
            if (width > 0) {
                gctx.lineWidth = width;
                gctx.strokeStyle = LINE_COLOR;
                gctx.stroke();
            }
        }

        function drawLineLocal(a, b, thickness = LINE_THICKNESS, color = null) { // <<< —Ü–≤–µ—Ç –æ—Ç –∏–≥—Ä–æ–∫–∞
            gctx.beginPath();
            gctx.moveTo(a[0], a[1]);
            gctx.lineTo(b[0], b[1]);
            gctx.lineWidth = thickness;
            gctx.strokeStyle = color || LINE_COLOR;
            gctx.lineCap = 'round';
            gctx.stroke();
        }

        function nearScaled(pos) {
            const hitR = Math.max(DR * 2, Math.round(SP * 0.4));
            for (let i = 0; i < pts.length; i++) {
                const p = pts[i].pos;
                const dx = p[0] - pos[0];
                const dy = p[1] - pos[1];
                if (dx * dx + dy * dy <= hitR * hitR) return i;
            }
            return null;
        }

        function sortedPair(a, b) { return a < b ? [a, b] : [b, a]; }

        function edgeKey(a, b) { // <<< –∫–ª—é—á —Ä–µ–±—Ä–∞
            const e = sortedPair(a, b);
            return `${e[0]}-${e[1]}`;
        }

        function line_ok_scaled(a, b) {
            const p1 = pts[a], p2 = pts[b];
            const q1 = p1.q, r1 = p1.r;
            const q2 = p2.q, r2 = p2.r;
            const d = Math.max(
                Math.abs(q1 - q2),
                Math.abs(r1 - r2),
                Math.abs((q1 + r1) - (q2 + r2))
            );
            if (d === 0) return [];
            if (!(
                (q1 - q2 === 0) ||
                (r1 - r2 === 0) ||
                ((q1 + r1) - (q2 + r2) === 0)
            )) return [];
            const dq = (q2 - q1) / d;
            const dr = (r2 - r1) / d;
            const path = [];
            for (let i = 0; i <= d; i++) {
                const q = Math.round(q1 + dq * i);
                const r = Math.round(r1 + dr * i);
                const key = `${q},${r}`;
                if (key in idx) path.push(idx[key]);
                else return [];
            }
            return path;
        }

        function find_triangles_local_scaled() {
            const found = [];
            const edgesSet = new Set(con.map(e => edgeKey(e[0], e[1])));
            const n = pts.length;
            for (let a = 0; a < n; a++) {
                for (let b = a + 1; b < n; b++) {
                    if (!edgesSet.has(edgeKey(a, b))) continue;
                    for (let c = b + 1; c < n; c++) {
                        if (edgesSet.has(edgeKey(b, c)) && edgesSet.has(edgeKey(a, c))) {
                            found.push([a, b, c]);
                        }
                    }
                }
            }
            return found;
        }

        function find_triangles_from_edges(edgesList) {
            const found = [];
            const edgesSet = new Set(edgesList.map(e => edgeKey(e[0], e[1])));
            const n = pts.length;
            for (let a = 0; a < n; a++) {
                for (let b = a + 1; b < n; b++) {
                    if (!edgesSet.has(edgeKey(a, b))) continue;
                    for (let c = b + 1; c < n; c++) {
                        if (edgesSet.has(edgeKey(b, c)) && edgesSet.has(edgeKey(a, c))) {
                            found.push([a, b, c]);
                        }
                    }
                }
            }
            return found;
        }

        // –ï—Å—Ç—å –ª–∏ –µ—â—ë –≤–æ–æ–±—â–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –Ω–æ–≤—ã–µ —Ö–æ–¥—ã (–Ω–æ–≤—ã–µ —Ä—ë–±—Ä–∞)?
        function hasAnyAvailableMove() {
            const n = pts.length;
            const existingEdges = new Set(con.map(e => edgeKey(e[0], e[1])));
            for (let a = 0; a < n; a++) {
                for (let b = a + 1; b < n; b++) {
                    const path = line_ok_scaled(a, b);
                    if (path.length === STEP_POINTS) {
                        for (let k = 0; k < path.length - 1; k++) {
                            const e = sortedPair(path[k], path[k + 1]);
                            const key = edgeKey(e[0], e[1]);
                            if (!existingEdges.has(key)) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function tri_center_scaled(tri_pts) {
            const xs = tri_pts.map(p => p[0]);
            const ys = tri_pts.map(p => p[1]);
            return [
                Math.floor((xs[0] + xs[1] + xs[2]) / 3),
                Math.floor((ys[0] + ys[1] + ys[2]) / 3)
            ];
        }

        function triKeyFromPoints(points) {
            return points.slice().sort((a, b) => a - b).join(',');
        }

        function arraysEqual(a, b) {
            if (a.length !== b.length) return false;
            for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
            return true;
        }

        function updateClaimCandidates() {
            const raw = find_triangles_local_scaled();
            const existing = new Set(tris.map(t => triKeyFromPoints(t.points)));
            claimCandidates = [];
            for (const t of raw) {
                const key = triKeyFromPoints(t);
                if (existing.has(key)) continue;
                const tri_pts = [pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos];
                const center = tri_center_scaled(tri_pts);
                claimCandidates.push({ points: t.slice(), center, key });
            }
        }

        function isBoardFull() { // –¥–æ—Å–∫–∞ –∑–∞–ø–æ–ª–Ω–µ–Ω–∞: –Ω–µ—Ç —Ö–æ–¥–æ–≤ –∏ –Ω–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Ç—Ä–∏—É–≥–æ–ª—å–Ω–∏–∫–æ–≤ /* <<< */
            updateClaimCandidates();
            const noMovesLeft = !hasAnyAvailableMove();
            const noFreeTriangles = claimCandidates.length === 0;
            return noMovesLeft && noFreeTriangles;
        }

        function checkLocalGameOver() { // —Ç–æ–ª—å–∫–æ –¥–ª—è single player /* <<< */
            if (!isSinglePlayer || game_over) return;
            if (!isBoardFull()) return;

            game_over = true;
            showWinnerOverlay();
            updateGameHUD();
            drawImmediate();
        }

        async function animateTriangleCentersScaled(new_tris_list) {
            animating = true;
            const temp = [];
            for (const item of new_tris_list) {
                temp.push([item.center, item.color]);
                drawFrame(sel, drag_pos, temp);
                await new Promise(r => setTimeout(r, Math.max(80, tri_delay)));
            }
            animating = false;
        }

        function drawFrame(sel_local = null, dragPos = null, temp_centers = null) {
            if (!gctx || !gameCanvas.width) return;

            gctx.fillStyle = BG;
            gctx.fillRect(0, 0, gameCanvas.clientWidth, gameCanvas.clientHeight);

            // –ª–∏–Ω–∏–∏ –ø–æ–¥ —Ü–≤–µ—Ç –∏–≥—Ä–æ–∫–∞ /* <<< */
            gctx.shadowColor = 'rgba(249,115,22,0.6)';
            gctx.shadowBlur = 5;
            for (const [a, b] of con) {
                const key = edgeKey(a, b);
                const owner = edgeOwner.has(key) ? edgeOwner.get(key) : null;
                const color = owner != null ? (PLAYERS_COLORS[owner] || LINE_COLOR) : LINE_COLOR;
                drawLineLocal(pts[a].pos, pts[b].pos, LINE_THICKNESS, color);
            }
            gctx.shadowBlur = 0;
            gctx.shadowColor = 'transparent';

            // —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏ ‚Äì –∫—Ä—É–ø–Ω–µ–µ
            for (const tri of tris) {
                try {
                    const ptsList = tri.points.map(i => pts[i].pos);
                    const color = PLAYERS_COLORS[tri.owner] || PLAYERS_COLORS[0];
                    const cx = (ptsList[0][0] + ptsList[1][0] + ptsList[2][0]) / 3;
                    const cy = (ptsList[0][1] + ptsList[1][1] + ptsList[2][1]) / 3;
                    const r = Math.max(10, Math.round(14 * gScale));
                    drawHexagonLocal(color, [cx, cy], r, true);
                } catch (e) { }
            }

            if (temp_centers) {
                for (const [center, color] of temp_centers) {
                    const r = Math.max(12, Math.round(16 * gScale));
                    drawHexagonLocal(color, center, r, true);
                }
            }

            // —Ç–æ—á–∫–∏ ‚Äì –∫—Ä—É–ø–Ω–µ–µ
            for (const p of pts) {
                drawHexagonLocal('rgba(15,23,42,1)', p.pos, DR + 8, true);
                drawHexagonLocal(DOT, p.pos, DR + 3, true);
            }

            // claimRects: —Ç–æ–ª—å–∫–æ hitbox –¥–ª—è –∫–ª–∏–∫–∞
            claimRects = [];
            if (claimMode && claimCandidates.length > 0) {
                for (const c of claimCandidates) {
                    const center = c.center;
                    const r = Math.round(28 * gScale);
                    claimRects.push({
                        x: center[0] - r,
                        y: center[1] - r,
                        w: r * 2,
                        h: r * 2,
                        tri: c.points
                    });
                }
            }

            if (sel_local !== null && dragPos) {
                gctx.setLineDash([8, 6]);
                gctx.lineWidth = LINE_THICKNESS;
                gctx.strokeStyle = '#facc15';
                gctx.shadowColor = 'rgba(250,204,21,0.7)';
                gctx.shadowBlur = 10;
                drawLineLocal(pts[sel_local].pos, dragPos, LINE_THICKNESS, '#facc15');
                gctx.setLineDash([]);
                gctx.shadowBlur = 0;
                gctx.shadowColor = 'transparent';
            }
        }

        function drawImmediate() {
            drawFrame(sel, drag_pos);
        }

        function updateGameHUD() { // –ø–æ–¥—Å–≤–µ—Ç–∫–∞ —Ö–æ–¥–∞ + –±–µ–∑ Moves /* <<< */
            const n = Math.max(
                playerNames ? playerNames.length : 0,
                score.length
            );
            if (n === 0) return;

            gameTopPlayers.innerHTML = '';
            gameBottomPlayer.innerHTML = '';

            const players = [];
            for (let i = 0; i < n; i++) {
                const nm = playerNames && playerNames[i] ? playerNames[i] : ('P' + (i + 1));
                players.push({ index: i, name: nm });
            }

            const meIdx = (currentPlayerIndex != null && currentPlayerIndex < n) ? currentPlayerIndex : 0;
            const me = players[meIdx];

            const myScore = score[meIdx] || 0;
            const isMyTurn = (turn === meIdx && !game_over);

            const meCard = document.createElement('div');
            const meClasses = ['game-player-card', 'me'];
            if (isMyTurn) meClasses.push('turn');
            meCard.className = meClasses.join(' ');

            meCard.innerHTML = `
      <div class="avatar-circle"></div>
      <div class="game-player-meta">
        <div class="game-player-label">${isMyTurn ? 'Your turn' : 'You'}</div>
        <div class="game-player-name">${me.name}</div>
        <div class="game-player-label">Score: ${myScore}</div>
      </div>
    `;
            gameBottomPlayer.appendChild(meCard);

            players.forEach(p => {
                if (p.index === meIdx) return;
                const sc = score[p.index] || 0;
                const card = document.createElement('div');
                const classes = ['game-player-card'];
                if (!game_over && turn === p.index) classes.push('turn');
                card.className = classes.join(' ');
                card.innerHTML = `
        <div class="avatar-circle"></div>
        <div class="game-player-meta">
          <div class="game-player-name">${p.name}</div>
          <div class="game-player-label">Score: ${sc}</div>
        </div>
      `;
                gameTopPlayers.appendChild(card);
            });

            if (endTurnBtn) {
                let canEnd = !game_over && gameStarted;
                if (currentRoomId && wsConnected && !isSinglePlayer) {
                    canEnd = canEnd && currentPlayerIndex === turn;
                }
                endTurnBtn.disabled = !canEnd;
            }
        }

        function showGameScreen() {
            mainMenu.style.display = 'none';
            lobbyWrap.style.display = 'none';
            gameScreen.style.display = 'flex';
            stopRoomsAutoRefresh();
            window.scrollTo(0, 0);
            setupCanvasSize();
            drawImmediate();
        }

        function handleGameStart(data) {
            isSinglePlayer = false;

            con = [];
            tris = [];
            edgeOwner.clear();

            score = Array.isArray(data.score) ? data.score.slice() : [0, 0, 0, 0];
            moves = Array.isArray(data.moves) ? data.moves.slice() : [DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES, DEFAULT_MOVES];

            turn = (typeof data.turn === 'number') ? data.turn : 0;
            game_over = false;
            winner = null;
            waiting_for_server = false;
            claimMode = false;
            claimCandidates = [];
            claimRects = [];
            gameStarted = true;

            playerNames = [];
            playerAvatars = [];

            if (Array.isArray(data.playerNames)) {
                playerNames = data.playerNames.slice();
            }
            if (Array.isArray(data.players)) {
                const maxIdx = Math.max(...data.players.map(p => p.index));
                playerNames = Array(maxIdx + 1).fill(null);
                playerAvatars = Array(maxIdx + 1).fill(null);
                data.players.forEach(p => {
                    playerNames[p.index] = p.name;
                    playerAvatars[p.index] = p.avatar || null;
                });
            }

            hideWinnerOverlay();
            updateGameHUD();
            showGameScreen();
        }

        function handleStateUpdate(data) {
            try {
                edgeOwner.clear();
                con = [];
                (data.con || []).forEach(item => {
                    if (Array.isArray(item)) {
                        const a = item[0];
                        const b = item[1];
                        const owner = item.length > 2 ? item[2] : null;
                        con.push([a, b]);
                        if (owner != null) edgeOwner.set(edgeKey(a, b), owner);
                    } else if (item && typeof item === 'object') {
                        const a = item.a;
                        const b = item.b;
                        if (typeof a === 'number' && typeof b === 'number') {
                            con.push([a, b]);
                            if (typeof item.owner === 'number') {
                                edgeOwner.set(edgeKey(a, b), item.owner);
                            }
                        }
                    }
                });
            } catch (e) {
                con = [];
                edgeOwner.clear();
            }

            if (Array.isArray(data.tris)) {
                tris = data.tris.map(tr => ({ points: tr.points.slice(), owner: tr.owner }));
            } else {
                const new_tris = data.new_tris || [];
                for (const tr of new_tris) {
                    const pts_trip = tr.points.slice();
                    const owner = tr.owner;
                    if (!tris.find(t => arraysEqual(t.points.slice().sort(), pts_trip.slice().sort()))) {
                        tris.push({ points: pts_trip, owner });
                    }
                }
            }

            if (Array.isArray(data.score)) score = data.score.slice();
            if (Array.isArray(data.moves)) moves = data.moves.slice();
            if (typeof data.turn === 'number') turn = data.turn;
            if (typeof data.game_over === 'boolean') game_over = data.game_over;
            if (typeof data.winner !== 'undefined') winner = data.winner;

            if (Array.isArray(data.playerNames)) playerNames = data.playerNames.slice();
            if (Array.isArray(data.players)) {
                const maxIdx = Math.max(...data.players.map(p => p.index));
                playerNames = Array(maxIdx + 1).fill(null);
                playerAvatars = Array(maxIdx + 1).fill(null);
                data.players.forEach(p => {
                    playerNames[p.index] = p.name;
                    playerAvatars[p.index] = p.avatar || null;
                });
            }

            waiting_for_server = false;

            updateClaimCandidates();
            if (turn !== currentPlayerIndex) {
                claimMode = false;
            }

            updateGameHUD();
            drawImmediate();
        }

        function showWinnerOverlay() { // –∏—Ç–æ–≥–∏: 1,2,3 –º–µ—Å—Ç–æ + 4 –ø—Ä–æ—Å—Ç–æ –æ—á–∫–∏ /* <<< */
            const n = Math.max(
                playerNames && playerNames.length ? playerNames.length : 0,
                score && score.length ? score.length : 0
            );
            if (!n) return;

            const players = [];
            for (let i = 0; i < n; i++) {
                const name = (playerNames && playerNames[i]) ? playerNames[i] : `Player ${i + 1}`;
                const pts = (score && typeof score[i] === 'number') ? score[i] : 0;
                const avatar = (playerAvatars && playerAvatars[i]) ? playerAvatars[i] : null;
                players.push({ index: i, name, score: pts, avatar });
            }

            players.sort((a, b) => b.score - a.score);

            const first = players[0];
            let firstAvatar = first.avatar;
            if (!firstAvatar && first.index === currentPlayerIndex && localAvatarDataUrl) {
                firstAvatar = localAvatarDataUrl;
            }

            if (firstAvatar) {
                winnerAvatarEl.style.backgroundImage = `url(${firstAvatar})`;
            } else {
                winnerAvatarEl.style.backgroundImage = '';
            }

            winnerEmojiEl.textContent = 'üèÜ';
            winnerTitleEl.textContent = '–ò–¢–û–ì–ò –ò–ì–†–´';
            winnerNameLabel.textContent = `1 –º–µ—Å—Ç–æ: ${first.name} ‚Äî ${first.score}`;

            const lines = [];
            if (players[1]) {
                lines.push(`2 –º–µ—Å—Ç–æ: ${players[1].name} ‚Äî ${players[1].score}`);
            }
            if (players[2]) {
                lines.push(`3 –º–µ—Å—Ç–æ: ${players[2].name} ‚Äî ${players[2].score}`);
            }
            if (players[3]) {
                lines.push(`${players[3].name}: ${players[3].score}`);
            }
            winnerSubtitleEl.innerHTML = lines.join('<br>');

            winnerCountdownValue = 10;
            winnerCountdownEl.textContent = `Returning to main menu in ${winnerCountdownValue}‚Ä¶`;

            if (winnerCountdownTimer) clearTimeout(winnerCountdownTimer);
            if (winnerCountdownInterval) clearInterval(winnerCountdownInterval);

            winnerOverlay.style.display = 'flex';

            winnerCountdownInterval = setInterval(() => {
                winnerCountdownValue = Math.max(0, winnerCountdownValue - 1);
                winnerCountdownEl.textContent = `Returning to main menu in ${winnerCountdownValue}‚Ä¶`;
                if (winnerCountdownValue <= 0) {
                    clearInterval(winnerCountdownInterval);
                }
            }, 1000);

            winnerCountdownTimer = setTimeout(() => {
                backToMainFromWinner();
            }, 10000);
        }

        function hideWinnerOverlay() {
            winnerOverlay.style.display = 'none';
            if (winnerCountdownTimer) clearTimeout(winnerCountdownTimer);
            if (winnerCountdownInterval) clearInterval(winnerCountdownInterval);
            winnerCountdownTimer = null;
            winnerCountdownInterval = null;
        }

        function backToMainFromWinner() {
            hideWinnerOverlay();
            resetRoomClientState();
            showMainMenu();
        }

        winnerSkipBtn.addEventListener('click', backToMainFromWinner);

        function handleGameOver(data) { // –æ–Ω–ª–∞–π–Ω: —Å–µ—Ä–≤–µ—Ä —Å–∫–∞–∑–∞–ª game_over -> –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏—Ç–æ–≥–∏ /* <<< */
            game_over = true;
            if (Array.isArray(data.score)) {
                score = data.score.slice();
            }
            if (Array.isArray(data.players)) {
                const maxIdx = Math.max(...data.players.map(p => p.index));
                playerNames = Array(maxIdx + 1).fill(null);
                playerAvatars = Array(maxIdx + 1).fill(null);
                data.players.forEach(p => {
                    playerNames[p.index] = p.name;
                    playerAvatars[p.index] = p.avatar || null;
                });
            }
            showWinnerOverlay();
            updateGameHUD();
            drawImmediate();
        }

        function canvasPosFromEvent(clientX, clientY) {
            const rect = gameCanvas.getBoundingClientRect();
            return {
                x: Math.round(clientX - rect.left),
                y: Math.round(clientY - rect.top)
            };
        }

        function localAcceptClaims(triangles) { // —Ç–æ–ª—å–∫–æ –Ω–∞—á–∏—Å–ª—è–µ—Ç –æ—á–∫–∏, —Ö–æ–¥ –Ω–µ –º–µ–Ω—è–µ—Ç /* <<< */
            const edgesSet = new Set(con.map(e => edgeKey(e[0], e[1])));
            const existing = new Set(tris.map(t => triKeyFromPoints(t.points)));
            const accepted = [];
            for (const tri of triangles) {
                const key = triKeyFromPoints(tri);
                if (existing.has(key)) continue;
                const [a, b, c] = tri;
                const e1 = sortedPair(a, b).join('-');
                const e2 = sortedPair(b, c).join('-');
                const e3 = sortedPair(a, c).join('-');
                if (edgesSet.has(e1) && edgesSet.has(e2) && edgesSet.has(e3)) {
                    tris.push({ points: tri.slice(), owner: turn });
                    accepted.push(tri.slice());
                }
            }
            if (accepted.length) {
                score[turn] = (score[turn] || 0) + accepted.length;
            }

            updateClaimCandidates();

            const new_tris_for_anim = accepted.map(t => ({
                points: t,
                center: tri_center_scaled([pts[t[0]].pos, pts[t[1]].pos, pts[t[2]].pos]),
                color: PLAYERS_COLORS[turn]
            }));
            if (new_tris_for_anim.length) {
                animateTriangleCentersScaled(new_tris_for_anim);
            }

            updateGameHUD();
            drawImmediate();
        }

        function applyLocalMoveFromPath(path, options = {}) { // –∫–∞–∂–¥—ã–π —Ö–æ–¥ —Ç—Ä–µ–±—É–µ—Ç End turn /* <<< */
            const { autoClaim = false } = options;

            if (!Array.isArray(path) || path.length < 2) return false;

            const newEdges = [];
            for (let k = 0; k < path.length - 1; k++) {
                const a = path[k], b = path[k + 1];
                const edge = sortedPair(a, b);
                if (!con.find(e => e[0] === edge[0] && e[1] === edge[1])) {
                    con.push(edge);
                    newEdges.push(edge);
                    edgeOwner.set(edgeKey(edge[0], edge[1]), turn);
                }
            }

            if (!newEdges.length) {
                return false;
            }

            updateClaimCandidates();

            // –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ö–æ–¥–∞ –≤–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º claim (–µ—Å–ª–∏ –µ—Å—Ç—å —Ç—Ä–µ—É–≥–æ–ª—å–Ω–∏–∫–∏ ‚Äî –º–æ–∂–Ω–æ –∑–∞–±–∏—Ä–∞—Ç—å, –µ—Å–ª–∏ –Ω–µ—Ç ‚Äî –≤—Å—ë —Ä–∞–≤–Ω–æ –Ω—É–∂–Ω–æ –Ω–∞–∂–∞—Ç—å End turn)
            claimMode = true;

            // –¥–ª—è –±–æ—Ç–∞ –º–æ–∂–Ω–æ —Å—Ä–∞–∑—É –∞–≤—Ç–æ–∫–ª–µ–π–º–∏—Ç—å
            if (autoClaim && claimCandidates.length > 0) {
                const triangles = claimCandidates.map(c => c.points);
                localAcceptClaims(triangles);
            }

            updateGameHUD();
            drawImmediate();

            return true;
        }

        function localEndTurn(options = {}) { // –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ö–æ–¥–∞ (single player –∏ –æ—Ñ—Ñ–ª–∞–π–Ω) /* <<< */
            if (!gameStarted || game_over) return;

            claimMode = false;

            checkLocalGameOver();
            if (game_over) return;

            const numPlayers = playerNames && playerNames.length ? playerNames.length : score.length;
            if (!numPlayers) return;

            turn = (turn + 1) % numPlayers;

            updateGameHUD();
            drawImmediate();

            if (isSinglePlayer) {
                const fromBot = options.fromBot === true;
                if (!fromBot && turn === 1) {
                    scheduleBotMove();
                }
            }
        }

        function scheduleBotMove() {
            if (!isSinglePlayer) return;
            const botIndex = 1;
            if (game_over || !gameStarted) return;
            if (turn !== botIndex) return;

            setTimeout(() => {
                if (!isSinglePlayer || game_over || !gameStarted || turn !== botIndex) return;
                botMakeMove();
            }, 400);
        }

        function botMakeMove() { // –±–æ—Ç —Ö–æ–¥–∏—Ç –∏ –ø–æ—Ç–æ–º —Å–∞–º –∂–º—ë—Ç End turn (—á–µ—Ä–µ–∑ localEndTurn) /* <<< */
            if (!isSinglePlayer || game_over || !gameStarted) return;

            const botIndex = 1;
            if (turn !== botIndex) return;

            const n = pts.length;
            const existingEdges = new Set(con.map(e => edgeKey(e[0], e[1])));
            const candidatePaths = [];

            for (let a = 0; a < n; a++) {
                for (let b = a + 1; b < n; b++) {
                    const path = line_ok_scaled(a, b);
                    if (path.length === STEP_POINTS) {
                        const newEdges = [];
                        let hasNew = false;
                        for (let k = 0; k < path.length - 1; k++) {
                            const e = sortedPair(path[k], path[k + 1]);
                            const key = edgeKey(e[0], e[1]);
                            if (!existingEdges.has(key)) {
                                hasNew = true;
                                newEdges.push(e);
                            }
                        }
                        if (hasNew) {
                            candidatePaths.push({ path, newEdges });
                        }
                    }
                }
            }

            if (!candidatePaths.length) {
                localEndTurn({ fromBot: true });
                return;
            }

            let best = [];
            let bestScore = -1;

            for (const cand of candidatePaths) {
                const hypotheticalEdges = con.concat(cand.newEdges);
                const raw = find_triangles_from_edges(hypotheticalEdges);
                const existingTriKeys = new Set(tris.map(t => triKeyFromPoints(t.points)));
                let newCount = 0;
                for (const t of raw) {
                    const key = triKeyFromPoints(t);
                    if (!existingTriKeys.has(key)) newCount++;
                }
                if (newCount > bestScore) {
                    bestScore = newCount;
                    best = [cand];
                } else if (newCount === bestScore) {
                    best.push(cand);
                }
            }

            const choice = best[Math.floor(Math.random() * best.length)];
            const moved = applyLocalMoveFromPath(choice.path, { autoClaim: true });
            if (moved) {
                localEndTurn({ fromBot: true });
            } else {
                localEndTurn({ fromBot: true });
            }
        }

        function handlePointerDown(ev) {
            ev.preventDefault();

            if (!gameStarted || animating || waiting_for_server || game_over) return;

            const pos = canvasPosFromEvent(ev.clientX, ev.clientY);
            const mx = pos.x, my = pos.y;

            pointerIsDown = true;
            drag_pos = null;

            if (claimMode) {
                sel = null;
                return;
            }

            if (currentRoomId && wsConnected && !isSinglePlayer && currentPlayerIndex !== turn) {
                return;
            }

            const i = nearScaled([mx, my]);
            if (i !== null) {
                sel = i;
                drag_pos = [mx, my];
                drawImmediate();
            } else {
                sel = null;
                drag_pos = null;
            }
        }

        function handlePointerMove(ev) {
            if (!pointerIsDown || sel === null || !gameStarted || animating || waiting_for_server || game_over) return;
            const pos = canvasPosFromEvent(ev.clientX, ev.clientY);
            drag_pos = [pos.x, pos.y];
            drawImmediate();
        }

        function handlePointerUp(ev) {
            if (!pointerIsDown) return;
            ev.preventDefault();
            const pos = canvasPosFromEvent(ev.clientX, ev.clientY);
            const mx = pos.x, my = pos.y;

            pointerIsDown = false;

            if (!gameStarted || animating || waiting_for_server || game_over) {
                sel = null;
                drag_pos = null;
                drawImmediate();
                return;
            }

            if (claimMode) {
                for (const r of claimRects) {
                    if (mx >= r.x && mx <= r.x + r.w && my >= r.y && my <= r.y + r.h) {
                        const triangles = [r.tri.slice()];
                        if (currentRoomId && wsConnected && !isSinglePlayer) {
                            waiting_for_server = true;
                            sendWS({ type: 'claim_triangles', room: currentRoomId, triangles });
                        } else {
                            localAcceptClaims(triangles);
                        }
                        sel = null;
                        drag_pos = null;
                        return;
                    }
                }
                sel = null;
                drag_pos = null;
                drawImmediate();
                return;
            }

            if (currentRoomId && wsConnected && !isSinglePlayer && currentPlayerIndex !== turn) {
                sel = null;
                drag_pos = null;
                drawImmediate();
                return;
            }

            const startIndex = sel;
            const endIndex = nearScaled([mx, my]);

            if (startIndex != null && endIndex != null && endIndex !== startIndex) {
                const path = line_ok_scaled(startIndex, endIndex);
                if (path.length === STEP_POINTS) {
                    const newEdges = [];
                    for (let k = 0; k < path.length - 1; k++) {
                        const a = path[k], b = path[k + 1];
                        const edge = sortedPair(a, b);
                        if (!con.find(e => e[0] === edge[0] && e[1] === edge[1])) {
                            newEdges.push(edge);
                        }
                    }

                    if (newEdges.length > 0) {
                        if (currentRoomId && wsConnected && !isSinglePlayer) {
                            waiting_for_server = true;
                            for (const e of newEdges) {
                                con.push(e);
                                edgeOwner.set(edgeKey(e[0], e[1]), turn);
                            }

                            const hypotheticalEdges = con.slice();
                            const raw = find_triangles_from_edges(hypotheticalEdges);
                            const existing = new Set(tris.map(t => triKeyFromPoints(t.points)));
                            const newCandidates = raw.filter(t => !existing.has(triKeyFromPoints(t)));

                            sendWS({ type: 'make_move', room: currentRoomId, path });

                            claimMode = true;
                            updateClaimCandidates();
                        } else {
                            applyLocalMoveFromPath(path, { autoClaim: false });
                        }
                    }
                }
            }

            sel = null;
            drag_pos = null;
            drawImmediate();
        }

        gameCanvas.addEventListener('pointerdown', (ev) => {
            gameCanvas.setPointerCapture(ev.pointerId);
            handlePointerDown(ev);
        });
        gameCanvas.addEventListener('pointermove', handlePointerMove);
        gameCanvas.addEventListener('pointerup', (ev) => {
            handlePointerUp(ev);
            try { gameCanvas.releasePointerCapture(ev.pointerId); } catch (e) { }
        });
        gameCanvas.addEventListener('pointercancel', () => {
            pointerIsDown = false;
            sel = null;
            drag_pos = null;
            drawImmediate();
        });

        if (endTurnBtn) {
            endTurnBtn.addEventListener('click', () => { // —Ç–µ–ø–µ—Ä—å –ø–æ—Å–ª–µ –ö–ê–ñ–î–û–ì–û —Ö–æ–¥–∞ –Ω—É–∂–Ω–æ –∂–∞—Ç—å End turn /* <<< */
                if (!gameStarted || game_over) return;

                if (isSinglePlayer || !currentRoomId || !wsConnected) {
                    localEndTurn();
                    return;
                }

                if (currentPlayerIndex !== turn) {
                    return;
                }

                waiting_for_server = true;
                claimMode = false;
                sendWS({ type: 'end_turn', room: currentRoomId });
                endTurnBtn.disabled = true;
            });
        }

        if (gameExitBtn) {
            gameExitBtn.addEventListener('click', () => {
                if (!isSinglePlayer && ws && ws.readyState === WebSocket.OPEN) {
                    ws.close();
                }
                gameStarted = false;
                resetRoomClientState();
                hideWinnerOverlay();
                showMainMenu();
            });
        }

        window.addEventListener('resize', () => {
            if (gameScreen.style.display !== 'none') {
                setupCanvasSize();
            }
        });

        /* ===== Single Player vs Bot ===== */
        function startSinglePlayerGame() {
            isSinglePlayer = true;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            stopRoomsAutoRefresh();

            con = [];
            tris = [];
            edgeOwner.clear();
            claimMode = false;
            claimCandidates = [];
            claimRects = [];
            game_over = false;
            winner = null;
            waiting_for_server = false;
            animating = false;
            gameStarted = true;

            const playerName = nameInput.value.trim() || 'Player';
            playerNames = [playerName, 'Bot'];
            playerAvatars = [localAvatarDataUrl || null, null];

            moves = [DEFAULT_MOVES, DEFAULT_MOVES];
            score = [0, 0];
            turn = 0;
            currentPlayerIndex = 0;

            hideWinnerOverlay();
            updateGameHUD();
            showGameScreen();
        }
    </script>

</body>

</html>
